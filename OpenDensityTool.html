<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>Typographic Density Tool</title>
        <script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
        <style>
            :root {
                --primary: #0070ea;
                --background: #f7f7f8;
                --surface: #fff;
                --text: #333;
                --border: #e0e0e0;
                --input: #fff
            }

            @media(prefers-color-scheme: dark) {
                :root:not(.light) {
                    --background:#10131b;
                    --surface: #181c23;
                    --text: #c1c6d7;
                    --border: #414754;
                    --input: #0f1218
                }
            }

            :root.dark {
                --background: #10131b;
                --surface: #181c23;
                --text: #c1c6d7;
                --border: #414754;
                --input: #0f1218
            }

            * {
                box-sizing: border-box
            }

            body {
                background: var(--background);
                color: var(--text);
                font-family: sans-serif;
                line-height: 1.5;
                margin: 0;
                padding: 24px
            }

            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 32px
            }

            h1 {
                margin: 0;
                font-size: 1.8em
            }

            main {
                display: grid;
                grid-template-columns: 340px 1fr;
                gap: 24px;
                max-width: 1600px;
                margin: 0 auto
            }

            section {
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 24px;
                min-width: 0
            }

            h2 {
                margin-top: 0;
                border-bottom: 1px solid var(--border);
                padding-bottom: 12px;
                font-size: 1.2em
            }

            .font-group {
                background: var(--background);
                border: 1px solid var(--border);
                padding: 16px;
                border-radius: 6px;
                margin-bottom: 16px
            }

            .font-header {
                display: flex;
                align-items: center;
                margin-bottom: 12px;
                font-weight: 700
            }

            input[type="color"] {
                width: 24px;
                height: 24px;
                border: none;
                background: none;
                padding: 0;
                margin-right: 8px;
                cursor: pointer
            }

            label {
                display: block;
                margin-bottom: 12px;
                font-size: .9em;
                opacity: .9
            }

            input:not([type="color"]),textarea,select {
                width: 100%;
                padding: 8px;
                border: 1px solid var(--border);
                border-radius: 4px;
                background: var(--input);
                color: var(--text);
                margin-top: 4px;
                font-family: inherit
            }

            textarea {
                resize: vertical;
                min-height: 60px
            }

            .row {
                display: flex;
                gap: 12px
            }

            .controls {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
                margin-bottom: 16px
            }

            .controls select {
                width: auto
            }

            button {
                background: var(--primary);
                color: #fff;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                margin-left: auto
            }

            button:hover {
                opacity: .9
            }

            #previewContainer {
                background: var(--input);
                border: 1px solid var(--border);
                border-radius: 6px;
                overflow: auto;
                margin-bottom: 24px
            }

            #canvasContainer {
                padding: 15px;
                display: flex;
                align-items: flex-start
            }

            canvas {
                transform-origin: top left;
                display: block;
                flex-shrink: 0
            }

            .results {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px
            }

            .result-card {
                background: var(--background);
                border: 1px solid var(--border);
                padding: 16px;
                border-radius: 6px
            }

            .result-text {
                white-space: pre-wrap;
                font-family: monospace;
                font-size: .9em;
                margin-top: 8px
            }

            .indicator {
                width: 12px;
                height: 12px;
                border-radius: 3px;
                display: inline-block;
                margin-right: 8px
            }

            @media(max-width: 900px) {
                main {
                    grid-template-columns:1fr
                }
            }
        </style>
    </head>
    <body>
        <header>
            <h1>Typographic Density Tool</h1>
            <select id="theme" style="width:auto">
                <option value="auto">Auto Theme</option>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
            </select>
        </header>
        <main>
            <section>
                <h2>Configuration</h2>
                <div class="font-group">
                    <div class="font-header">
                        <input type="color" id="color1" value="#00a2a2">Font 1
					
                    </div>
                    <label>
                        Font File<input type="file" id="file1" accept=".otf,.ttf,.woff">
                    </label>
                    <label>
                        Text<textarea id="text1" maxlength="1000">Idealogy</textarea>
                    </label>
                    <label>
                        Size (px)<input type="number" id="size1" value="100" min="8" max="500">
                    </label>
                    <div class="row">
                        <label>
                            Letter Spacing<input type="number" id="spacing1" value="0" min="-100" max="100">
                        </label>
                        <label>
                            Baseline Shift<input type="number" id="shift1" value="0" min="-200" max="200">
                        </label>
                    </div>
                </div>
                <div class="font-group">
                    <div class="font-header">
                        <input type="color" id="color2" value="#ff00ff">Font 2
					
                    </div>
                    <label>
                        Font File<input type="file" id="file2" accept=".otf,.ttf,.woff">
                    </label>
                    <label>
                        Text<textarea id="text2" maxlength="1000">Идеология</textarea>
                    </label>
                    <label>
                        Size (px)<input type="number" id="size2" value="100" min="8" max="500">
                    </label>
                    <div class="row">
                        <label>
                            Letter Spacing<input type="number" id="spacing2" value="0" min="-100" max="100">
                        </label>
                        <label>
                            Baseline Shift<input type="number" id="shift2" value="0" min="-200" max="200">
                        </label>
                    </div>
                </div>
            </section>
            <section>
                <h2>Visualization</h2>
                <div class="controls">
                    <select id="zoom">
                        <option value="fit">Fit to View</option>
                        <option value="100">100% Scale</option>
                    </select>
                    <select id="render">
                        <option value="overlay">Overlay</option>
                        <option value="side-by-side">Side-by-side</option>
                    </select>
                    <select id="density">
                        <option value="ink-box">Ink Box</option>
                        <option value="em-box">Em Box</option>
                    </select>
                    <button id="exportButton">Export PNG</button>
                </div>
                <div id="previewContainer">
                    <div id="canvasContainer">
                        <canvas id="canvas"></canvas>
                    </div>
                </div>
                <div class="results">
                    <div class="result-card">
                        <div class="font-header">
                            <div id="indicator1" class="indicator"></div>
                            Font 1 Analysis
						
                        </div>
                        <div id="result1" class="result-text">Load a font.</div>
                    </div>
                    <div class="result-card">
                        <div class="font-header">
                            <div id="indicator2" class="indicator"></div>
                            Font 2 Analysis
						
                        </div>
                        <div id="result2" class="result-text">Load a font.</div>
                    </div>
                </div>
            </section>
        </main>
        <script>
            const node = (tag,props)=>Object.assign(document.createElement(tag), props);
            const download = (href,name)=>node('a', {
                href,
                download: name
            }).click();
            const timestamp = ()=>new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
            const dom = Object.fromEntries([...document.querySelectorAll('[id]')].map(item=>[item.id, item]));

            class DensityTool {
                constructor() {
                    this.fonts = [null, null];
                    this.analyses = [null, null];
                    this.colors = [dom.color1.value, dom.color2.value];
                    this.frames = {};
                    this.graphWidth = 150;
                    this.graphPadding = 20;
                    this.context = dom.canvas.getContext('2d');
                    this.tintCanvas = node('canvas');
                    this.tintContext = this.tintCanvas.getContext('2d', {
                        willReadFrequently: true
                    });
                    this.configs = [1, 2].map(i=>({
                        file: dom[`file${i}`],
                        text: dom[`text${i}`],
                        size: dom[`size${i}`],
                        spacing: dom[`spacing${i}`],
                        shift: dom[`shift${i}`],
                        color: dom[`color${i}`],
                        result: dom[`result${i}`],
                        indicator: dom[`indicator${i}`]
                    }));
                    this.bind();
                    this.setTheme('auto');
                    this.update();
                }

                bind() {
                    const schedule = (key,handler)=>()=>{
                        if (this.frames[key])
                            cancelAnimationFrame(this.frames[key]);
                        this.frames[key] = requestAnimationFrame(handler);
                    }
                    ;
                    const refresh = schedule('refresh', ()=>this.update());
                    const resize = schedule('resize', ()=>this.updateScale());

                    dom.zoom.onchange = resize;
                    dom.render.onchange = dom.density.onchange = refresh;
                    dom.exportButton.onclick = ()=>this.exportImage();
                    dom.theme.onchange = e=>this.setTheme(e.target.value);
                    window.onresize = resize;

                    this.configs.forEach((config,i)=>{
                        config.file.onchange = e=>this.loadFont(e.target.files[0], i);
                        config.color.oninput = e=>{
                            this.colors[i] = e.target.value;
                            refresh();
                        }
                        ;
                        [config.text, config.size, config.spacing, config.shift].forEach(input=>input.oninput = refresh);
                    }
                    );
                }

                setTheme(theme) {
                    document.documentElement.classList.remove('light', 'dark');
                    if (theme !== 'auto')
                        document.documentElement.classList.add(theme);
                    dom.theme.value = theme;
                }

                async loadFont(file, index) {
                    if (!file || file.size > 30 * 1024 * 1024)
                        return file && alert('File too large');
                    try {
                        const font = opentype.parse(await file.arrayBuffer());
                        if (!font.draw)
                            throw new Error('Invalid font');
                        this.fonts[index] = font;
                        this.update();
                    } catch (error) {
                        alert(error.message);
                    }
                }

                computeMetrics(font, content, fontSize, letterSpacing) {
                    const scale = fontSize / font.unitsPerEm
                      , {os2, hhea} = font.tables;
                    const metric = keys=>Math.max(0, ...keys.map(k=>Math.abs(font[k] ?? os2?.[k] ?? hhea?.[k] ?? 0)).filter(v=>!isNaN(v))) * scale;
                    const extents = font.stringToGlyphs(content).reduce((r,g)=>{
                        const b = g.path?.getBoundingBox?.();
                        if (b && isFinite(b.y1) && isFinite(b.y2)) {
                            r.actualAscent = Math.max(r.actualAscent, b.y2);
                            r.actualDescent = Math.max(r.actualDescent, -b.y1);
                        }
                        return r;
                    }
                    , {
                        actualAscent: 0,
                        actualDescent: 0
                    });

                    const fontAscent = metric(['ascender', 'sTypoAscender', 'usWinAscent']);
                    const fontDescent = metric(['descender', 'sTypoDescender', 'usWinDescent']);
                    const options = {
                        tracking: letterSpacing ? (letterSpacing / fontSize) * 1000 : 0
                    };
                    const bounds = font.getPath(content, 0, 0, fontSize, options).getBoundingBox();

                    return {
                        ascent: Math.max(Math.max(extents.actualAscent * scale, -bounds.y1), fontAscent),
                        descent: Math.max(Math.max(extents.actualDescent * scale, bounds.y2), fontDescent),
                        actualAscent: Math.max(extents.actualAscent * scale, -bounds.y1),
                        actualDescent: Math.max(extents.actualDescent * scale, bounds.y2),
                        fontAscent,
                        fontDescent,
                        x1: bounds.x1,
                        x2: bounds.x2,
                        boundingBoxWidth: Math.ceil(bounds.x2 - bounds.x1),
                        advanceWidth: Math.ceil(font.getAdvanceWidth(content, fontSize, options))
                    };
                }

                analyze(font, content, fontSize, baselineShift, letterSpacing) {
                    if (!font || !content || !fontSize)
                        return null;
                    const size = Math.max(1, Math.min(fontSize, 2000));
                    const tracking = letterSpacing ? (letterSpacing / size) * 1000 : 0;
                    const metrics = this.computeMetrics(font, content, size, letterSpacing);
                    if (!metrics || (metrics.advanceWidth <= 0 && metrics.boundingBoxWidth <= 0))
                        return null;

                    const minX = Math.min(0, metrics.x1)
                      , maxX = Math.max(metrics.advanceWidth, metrics.x2);
                    const drawOffsetX = -minX
                      , width = Math.ceil(maxX - minX);
                    const baseline = Math.ceil(metrics.ascent)
                      , height = Math.ceil(baseline + metrics.descent);

                    const fontCanvas = node('canvas', {
                        width,
                        height
                    });
                    font.draw(fontCanvas.getContext('2d', {
                        willReadFrequently: true
                    }), content, drawOffsetX, baseline, size, {
                        tracking: tracking || 0
                    });

                    const pixels = this.analyzePixels(fontCanvas);
                    if (pixels.minY > pixels.maxY)
                        return null;

                    const area = dom.density.value === 'ink-box' ? (pixels.maxX - pixels.minX + 1) * (pixels.maxY - pixels.minY + 1) : Math.max(1, metrics.advanceWidth) * (metrics.ascent + metrics.descent);

                    return {
                        ...pixels,
                        ...metrics,
                        drawOffsetX,
                        canvas: fontCanvas,
                        baseline,
                        baselineShift,
                        letterSpacing,
                        fontSize: size,
                        font,
                        density: ((pixels.inkPixels / area) * 100).toFixed(1),
                        yMin: Math.round(baseline - pixels.maxY),
                        yMax: Math.round(baseline - pixels.minY)
                    };
                }

                analyzePixels(canvas) {
                    const width = canvas.width;
                    const height = canvas.height;

                    const context = canvas.getContext('2d', {
                        willReadFrequently: true
                    });
                    const {data} = context.getImageData(0, 0, width, height);

                    const densityByRow = new Float32Array(height);

                    let inkPixels = 0;
                    let minX = width;
                    let maxX = -1;
                    let minY = height;
                    let maxY = -1;

                    const rowStride = width * 4;
                    const alphaOffset = 3;
                    const threshold = 128;

                    for (let y = 0; y < height; y++) {
                        let index = y * rowStride + alphaOffset;

                        for (let x = 0; x < width; x++,
                        index += 4) {
                            if (data[index] < threshold)
                                continue;

                            inkPixels++;
                            densityByRow[y]++;

                            if (x < minX)
                                minX = x;
                            if (x > maxX)
                                maxX = x;
                            if (y < minY)
                                minY = y;
                            if (y > maxY)
                                maxY = y;
                        }
                    }

                    return {
                        densityByRow,
                        inkPixels,
                        minX,
                        maxX,
                        minY,
                        maxY
                    };
                }

                update() {
                    this.analyses = this.configs.map((c,i)=>{
                        c.indicator.style.backgroundColor = this.colors[i];
                        return this.analyze(this.fonts[i], c.text.value, +c.size.value || 0, +c.shift.value || 0, +c.spacing.value || 0);
                    }
                    );
                    this.draw();
                    this.updateResults();
                }

                draw() {
                    const valid = this.analyses.filter(Boolean);
                    if (!valid.length)
                        return this.renderEmpty();

                    const dims = this.computeDimensions(valid);
                    dom.canvas.width = dims.width;
                    dom.canvas.height = dims.height;
                    this.context.clearRect(0, 0, dims.width, dims.height);

                    const sideBySide = dom.render.value === 'side-by-side' && valid.length > 1;
                    let textOffsetX = this.graphWidth + this.graphPadding + (sideBySide ? 0 : dims.maxDrawOffsetX);

                    valid.forEach(analysis=>{
                        const yOffset = dims.baseline - analysis.baseline - analysis.baselineShift;
                        const blend = this.analyses.every(Boolean) && this.analyses.indexOf(analysis) > 0;
                        const color = this.colors[this.analyses.indexOf(analysis)];
                        this.renderGraph(analysis, color, yOffset, blend);
                        this.renderGlyphs(analysis, color, sideBySide ? textOffsetX + (analysis.drawOffsetX || 0) : textOffsetX, yOffset, blend);
                        if (sideBySide)
                            textOffsetX += analysis.canvas.width;
                    }
                    );
                    this.updateScale();
                }

                computeDimensions(analyses) {
                    const sideBySide = dom.render.value === 'side-by-side' && analyses.length > 1;
                    const maxAscent = Math.max(0, ...analyses.map(a=>a.baseline + a.baselineShift));
                    const maxDescent = Math.max(0, ...analyses.map(a=>a.canvas.height - a.baseline - a.baselineShift));
                    const maxDrawOffsetX = Math.max(0, ...analyses.map(a=>a.drawOffsetX));
                    const textWidth = sideBySide ? analyses.reduce((w,a)=>w + a.canvas.width, 0) : maxDrawOffsetX + Math.max(0, ...analyses.map(a=>a.canvas.width - a.drawOffsetX));
                    return {
                        width: Math.ceil(this.graphWidth + this.graphPadding + textWidth),
                        height: Math.ceil(maxAscent + maxDescent),
                        baseline: Math.ceil(maxAscent),
                        maxDrawOffsetX
                    };
                }

                renderGraph(analysis, color, yOffset, blend) {
                    const max = Math.max(1, ...analysis.densityByRow);
                    this.context.fillStyle = color;
                    this.context.globalCompositeOperation = blend ? 'multiply' : 'source-over';
                    analysis.densityByRow.forEach((v,y)=>{
                        if (v)
                            this.context.fillRect(this.graphWidth - (v / max) * this.graphWidth, y + yOffset, (v / max) * this.graphWidth, 1);
                    }
                    );
                    this.context.globalCompositeOperation = 'source-over';
                }

                renderGlyphs(analysis, color, originX, yOffset, blend) {
                    const {canvas} = analysis;
                    this.tintCanvas.width = canvas.width;
                    this.tintCanvas.height = canvas.height;
                    this.tintContext.globalCompositeOperation = 'source-over';
                    this.tintContext.fillStyle = color;
                    this.tintContext.fillRect(0, 0, canvas.width, canvas.height);
                    this.tintContext.globalCompositeOperation = 'destination-in';
                    this.tintContext.drawImage(canvas, 0, 0);
                    this.context.globalCompositeOperation = blend ? 'multiply' : 'source-over';
                    this.context.drawImage(this.tintCanvas, originX - (analysis.drawOffsetX || 0), yOffset);
                    this.context.globalCompositeOperation = 'source-over';
                }

                renderEmpty() {
                    dom.canvas.height = 150;
                    this.context.clearRect(0, 0, dom.canvas.width, 150);
                    this.updateScale();
                }

                updateScale() {
                    const {canvas, canvasContainer, previewContainer} = dom;
                    const fit = dom.zoom.value === 'fit' && canvas.width;
                    canvas.style.transform = 'none';
                    canvasContainer.style.width = canvasContainer.style.height = canvasContainer.style.overflow = '';
                    if (!fit)
                        return;

                    const style = getComputedStyle(canvasContainer);
                    const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
                    const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
                    const scale = Math.min((previewContainer.clientWidth - paddingX) / canvas.width, 1);
                    canvas.style.transform = `scale(${scale})`;
                    canvasContainer.style.width = `${canvas.width * scale + paddingX}px`;
                    canvasContainer.style.height = `${canvas.height * scale + paddingY}px`;
                    canvasContainer.style.overflow = 'hidden';
                }

                updateResults() {
                    this.configs.forEach((c,i)=>{
                        const a = this.analyses[i];
                        c.result.textContent = a ? `Density: ${a.density}%\n\nInk Bounds:\n- Max Y: ${a.yMax}\n- Min Y: ${a.yMin}\n\nMetrics:\n- Ascent: ${Math.round(a.fontAscent)}\n- Descent: ${Math.round(a.fontDescent)}` : this.fonts[i] ? 'Enter text.' : 'Load font.';
                    }
                    );
                }

                exportImage() {
                    download(dom.canvas.toDataURL(), `density_${timestamp()}.png`);
                }
            }

            new DensityTool();
        </script>
    </body>
</html>
