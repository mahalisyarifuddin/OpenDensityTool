<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Typographic Density Tool</title>
		<style>
			:root {
				--primary: #005dac;
				--on-primary: #ffffff;
				--hover: #00539a;
				--background: #f9f9ff;
				--surface: #ffffff;
				--text: #181c21;
				--border: #c1c6d4;
				--muted: #f2f3fc;
				--success: #0b6b1d;
				--on-success: #ffffff;
				--danger: #ba1a1a;
				--on-danger: #ffffff;
				--highlight-bg: #d4e3ff;
			}
			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--primary: #a5c8ff;
					--on-primary: #00315f;
					--hover: #72adff;
					--background: #101319;
					--surface: #0b0e14;
					--text: #e0e2ea;
					--border: #414752;
					--muted: #181c21;
					--success: #82db7e;
					--on-success: #00390a;
					--danger: #ffb4ab;
					--on-danger: #93000a;
					--highlight-bg: #001c3a;
				}
			}
			:root.dark {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
			*:focus-visible {
				outline: 2px solid var(--primary);
				outline-offset: 2px;
			}
			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				line-height: 1.25;
				padding: 1.5rem;
				min-height: 100vh;
			}
			header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 2rem;
				max-width: 1600px;
				margin-left: auto;
				margin-right: auto;
			}
			h1 {
				margin: .5rem 0;
				font-size: 2rem;
				font-weight: 600;
			}
			main {
				display: grid;
				grid-template-columns: 330px 1fr;
				gap: 1.5rem;
				max-width: 1600px;
				margin: 0 auto;
			}
			section {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 1.5rem;
				min-width: 0;
			}
			h2 {
				margin: .5rem 0 1rem;
				border-bottom: 1px solid var(--border);
				padding-bottom: .75rem;
				font-size: 1.2rem;
				font-weight: 600;
			}
			.group {
				background: var(--background);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				margin-bottom: 1rem;
				position: relative;
			}
			.group.dragActive {
				border-color: var(--primary);
				background: var(--surface);
			}
			.group.dragActive::after {
				content: "Drop Font File";
				position: absolute;
				inset: 0;
				background: var(--surface);
				color: var(--primary);
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				font-weight: 700;
				border-radius: 6px;
				z-index: 10;
			}
			.header {
				display: flex;
				align-items: center;
				margin-bottom: .75rem;
				font-weight: 700;
			}
			.header span {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				min-width: 0;
			}
			input[type=color] {
				width: 24px;
				height: 24px;
				border: none;
				background: none;
				padding: 0;
				margin-right: .5em;
				cursor: pointer;
				flex-shrink: 0;
			}
			label {
				display: block;
				margin-bottom: .5rem;
				font-weight: 500;
				font-size: .9rem;
			}
			input:not([type=color]), textarea, select, button {
				width: 100%;
				padding: .5rem .75rem;
				border: 1px solid var(--border);
				border-radius: 4px;
				background: var(--surface);
				color: var(--text);
				margin-top: 4px;
				font-family: inherit;
				font-size: .95rem;
			}
			textarea {
				resize: vertical;
				min-height: 80px;
				font-family: monospace;
				font-size: .8rem;
			}
			.row {
				display: flex;
				gap: 1rem;
			}
			.controls {
				display: flex;
				gap: .75rem;
				align-items: center;
				margin-bottom: 1rem;
			}
			.controlsSelection {
				display: flex;
				flex-wrap: wrap;
				gap: .75rem;
				flex: 1;
			}
			.controls select, button {
				width: auto;
				margin-top: 0;
				flex-shrink: 0;
			}
			button {
				background: var(--primary);
				color: var(--on-primary);
				border: 0;
				padding: .5rem 1rem;
				cursor: pointer;
			}
			button:hover {
				background: var(--hover);
			}
			dialog {
				background: var(--surface);
				color: var(--text);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 1.5rem;
				max-width: 400px;
				width: 100%;
				margin: auto;
				position: fixed;
			}
			dialog::backdrop {
				background: rgba(0, 0, 0, 0.5);
			}
			.dialog-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 1.5rem;
			}
			.dialog-header h3 {
				font-size: 1.25rem;
				font-weight: 600;
			}
			.close-button {
				background: transparent;
				color: var(--text);
				padding: .25rem;
				font-size: 1.5rem;
				line-height: 1;
			}
			.close-button:hover {
				background: var(--background);
				color: var(--text);
			}
			#preview {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto;
				margin-bottom: 1.5rem;
			}
			#container {
				padding: 1rem;
				display: flex;
				align-items: flex-start;
			}
			canvas {
				transform-origin: top left;
				display: block;
				flex-shrink: 0;
			}
			.results {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 1rem;
			}
			.card {
				background: var(--background);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				min-width: 0;
			}
			.output {
				font-family: monospace;
				font-size: .8rem;
				line-height: 1.5;
				margin-top: .5rem;
			}
			.statisticGrid {
				display: grid;
				gap: .5rem;
			}
			.statisticRow {
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.statisticGroup {
				margin-top: .5rem;
				border-top: 1px solid var(--border);
				padding-top: .5rem;
			}
			.statisticTitle {
				font-weight: 600;
				margin-bottom: .25rem;
				color: var(--text);
			}
			.statisticLabel {
				color: var(--text);
				opacity: .8;
			}
			.statisticValue {
				font-weight: 600;
			}
			.indicator {
				width: 14px;
				height: 14px;
				border-radius: 3px;
				display: inline-block;
				margin-right: .5em;
				flex-shrink: 0;
			}
			.actionButton {
				margin-left: auto;
				background: transparent;
				color: var(--primary);
				border: 1px solid transparent;
				padding: .25rem .5rem;
				font-size: .8rem;
				border-radius: 4px;
			}
			.actionButton:hover {
				background: var(--background);
				border-color: var(--muted);
				color: var(--hover);
			}
			.actionButton.active {
				background: var(--primary);
				color: var(--on-primary);
			}
			.actionButton.active:hover {
				background: var(--hover);
				color: var(--on-primary);
			}
			.spinner {
				width: 24px;
				height: 24px;
				border: 3px solid var(--border);
				border-top-color: var(--primary);
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin: 1rem auto;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			[hidden] {
				display: none !important;
			}
			@media (max-width: 900px) {
				main {
					grid-template-columns: 1fr;
				}
				.results {
					grid-template-columns: 1fr;
				}
			}
			.row label {
				display: flex;
				flex-direction: column;
				gap: 4px;
				flex: 1;
				min-width: 0;
			}
			.row label input {
				margin-top: auto;
			}
		</style>
	</head>
	<body>
		<header>
			<h1>Typographic Density Tool</h1>
			<button id="openSettings" style="width:auto" aria-label="Open Settings">Settings</button>
		</header>
		<dialog id="preferencesDialog">
			<div class="dialog-header">
				<h3>Preferences</h3>
				<button id="closeSettings" class="close-button" aria-label="Close Settings">&times;</button>
			</div>
			<div class="group">
				<label>
					Theme
					<select id="theme" style="margin-top:4px">
						<option value="auto">Auto Theme</option>
						<option value="light">Light</option>
						<option value="dark">Dark</option>
					</select>
				</label>
				<label>
					Letter Spacing Unit
					<select id="spacingUnit" style="margin-top:4px">
						<option value="em" selected>Per mille (‰ em)</option>
						<option value="px">Pixels (px)</option>
						<option value="percent">Tracking (%)</option>
					</select>
				</label>
			</div>
		</dialog>
		<main>
			<section>
				<h2>Configuration</h2>
				<div class="group">
					<div class="header">
						<input type="color" id="color1" value="#00a2a2" aria-label="Font 1 Color">
						<span id="name1">Font 1</span>
						<div class="controls" style="margin:0 0 0 auto;gap:4px">
							<button id="mute1" class="actionButton" aria-label="Toggle visibility Font 1" title="Toggle Visibility">M</button>
							<button id="solo1" class="actionButton" aria-label="Solo Font 1" title="Solo">S</button>
						</div>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file1" style="margin-bottom:0">Font File</label>
						<button id="clear1" class="actionButton" aria-label="Clear Font 1" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file1" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<label>
						Text<textarea id="text1" maxlength="1000">Idealogy</textarea>
					</label>
					<label>
						Size (px)<input type="number" id="size1" value="100" min="8" max="500">
					</label>
					<div class="row">
						<label>
							Letter Spacing (‰ em)<input type="number" id="spacing1" value="0" min="-500" max="500">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift1" value="0" min="-200" max="200">
						</label>
					</div>
				</div>
				<div class="group">
					<div class="header">
						<input type="color" id="color2" value="#ff00ff" aria-label="Font 2 Color">
						<span id="name2">Font 2</span>
						<div class="controls" style="margin:0 0 0 auto;gap:4px">
							<button id="mute2" class="actionButton" aria-label="Toggle visibility Font 2" title="Toggle Visibility">M</button>
							<button id="solo2" class="actionButton" aria-label="Solo Font 2" title="Solo">S</button>
						</div>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file2" style="margin-bottom:0">Font File</label>
						<button id="clear2" class="actionButton" aria-label="Clear Font 2" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file2" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<label>
						Text<textarea id="text2" maxlength="1000">Идеология</textarea>
					</label>
					<label>
						Size (px)<input type="number" id="size2" value="100" min="8" max="500">
					</label>
					<div class="row">
						<label>
							Letter Spacing (‰ em)<input type="number" id="spacing2" value="0" min="-500" max="500">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift2" value="0" min="-200" max="200">
						</label>
					</div>
				</div>
			</section>
			<section>
				<h2>Visualization</h2>
				<div class="controls">
					<div class="controlsSelection">
						<select id="zoom" aria-label="Zoom level">
							<option value="fit">Fit to View</option>
							<option value="100">100% Scale</option>
						</select>
						<select id="render" aria-label="Render mode">
							<option value="overlay">Overlay</option>
							<option value="side">Side-by-side</option>
						</select>
						<select id="density" aria-label="Density calculation method">
							<option value="ink">Ink Box</option>
							<option value="em">Em Box</option>
						</select>
						<select id="guides" aria-label="Guides">
							<option value="none">No Guides</option>
							<option value="baseline">Show Baseline</option>
							<option value="metrics">Show Metrics</option>
						</select>
					</div>
					<button id="export">Export PNG</button>
				</div>
				<div id="preview">
					<div id="container">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results">
					<div class="card">
						<div class="header">
							<div id="dot1" class="indicator"></div>
							<span id="analysisName1">Font 1 Analysis</span>
							<button class="actionButton copyButton" data-target="result1" aria-label="Copy Font 1 analysis">Copy</button>
						</div>
						<div id="result1" class="output" aria-live="polite"></div>
					</div>
					<div class="card">
						<div class="header">
							<div id="dot2" class="indicator"></div>
							<span id="analysisName2">Font 2 Analysis</span>
							<button class="actionButton copyButton" data-target="result2" aria-label="Copy Font 2 analysis">Copy</button>
						</div>
						<div id="result2" class="output" aria-live="polite"></div>
					</div>
				</div>
			</section>
		</main>
		<script type="module">
			import * as fontkitModule from 'https://esm.sh/fontkit@2.0.4';
			import { Buffer } from 'https://esm.sh/buffer@6.0.3';

			const fontkit = fontkitModule.default || fontkitModule;
			window.Buffer = Buffer;
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
			const isLittleEndianArchitecture = new Uint8Array(new Uint32Array([1]).buffer)[0] === 1;
			const ALPHA_SHIFT = isLittleEndianArchitecture ? 31 : 7;

			const COMMON_SCRIPT_NAMES = new Set('General Punctuation|Superscripts and Subscripts|Currency Symbols|Combining Diacritical Marks for Symbols|Letterlike Symbols|Number Forms|Arrows|Mathematical Operators|Miscellaneous Technical|Control Pictures|Optical Character Recognition|Enclosed Alphanumerics|Box Drawing|Block Elements|Geometric Shapes|Miscellaneous Symbols|Dingbats|Miscellaneous Mathematical Symbols-A|Supplemental Arrows-A|Braille Patterns|Supplemental Arrows-B|Miscellaneous Mathematical Symbols-B|Supplemental Mathematical Operators|Miscellaneous Symbols and Arrows|Supplemental Punctuation|CJK Symbols and Punctuation|Halfwidth and Fullwidth Forms'.split('|'));
			const row = (l, v) => `<div class="statisticRow"><span class="statisticLabel">${l}</span><span class="statisticValue">${v}</span></div>`;

			class DensityTool {
				constructor() {
					this.fonts = [];
					this.loadErrors = [];
					this.visibility = [true, true];
					this.solo = [false, false];
					this.loading = [false, false];
					this.loadSequence = [0, 0];
					this.renderingCache = [];
					this.layoutCache = [null, null];
					this.offscreenCanvases = [document.createElement('canvas'), document.createElement('canvas')];
					this.compositeCanvas = document.createElement('canvas');
					this.graphWidth = 150;
					this.graphPadding = 20;
					this.context = elements.canvas.getContext('2d');
					this.unicodeBlocks = [];
					this.surfaceColor = '#ffffff';
					this.analyses = [];
					this.setup();
					this.theme('auto');
					this.update();
				}

				setup() {
					this.fetchUnicodeBlocks();

					const debounce = (callback, delay) => {
						let timer;
						return (...args) => {
							clearTimeout(timer);
							timer = setTimeout(() => callback(...args), delay);
						};
					};
					const debouncedUpdate = debounce(() => this.update(), 300);
					const updateScale = () => this.updateScale();

					elements.zoom.onchange = updateScale;
					['render', 'density', 'guides'].forEach(id => {
						elements[id].onchange = () => this.update();
					});

					elements.export.onclick = () => {
						const link = document.createElement('a');
						link.href = elements.canvas.toDataURL();
						link.download = `density_${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.png`;
						link.click();
					};

					elements.theme.onchange = event => this.theme(event.target.value);

					window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
						this.updateThemeColor();
						elements.theme.value === 'auto' && this.draw();
					});

					elements.openSettings.onclick = () => elements.preferencesDialog.showModal();
					elements.closeSettings.onclick = () => elements.preferencesDialog.close();
					elements.spacingUnit.onchange = () => {
						this.updateSpacingLabels();
						this.update();
					};

					window.onresize = updateScale;

					document.querySelectorAll('.copyButton').forEach(button => {
						const originalText = button.textContent;
						button.onclick = () => {
							const text = document.getElementById(button.dataset.target).innerText;
							navigator.clipboard.writeText(text)
								.then(() => button.textContent = 'Copied!')
								.catch(() => button.textContent = 'Error')
								.finally(() => setTimeout(() => button.textContent = originalText, 2000));
						};
					});

					[1, 2].forEach((number, index) => {
						const fileInput = elements[`file${number}`];
						const group = fileInput.closest('.group');

						fileInput.onchange = event => this.loadFont(event.target.files[0], index);

						elements[`clear${number}`].onclick = () => {
							this.fonts[index] = null;
							this.loadErrors[index] = null;
							fileInput.value = '';
							this.update();
						};

						['color', 'text', 'size', 'spacing', 'shift'].forEach(key => {
							elements[`${key}${number}`].oninput = debouncedUpdate;
						});

						elements[`spacing${number}`].oninput = () => {
							elements[`spacing${number}`].setAttribute('value', elements[`spacing${number}`].value);
							debouncedUpdate();
						};

						group.ondragover = event => {
							event.preventDefault();
							group.classList.add('dragActive');
						};

						group.ondragleave = event => {
							if (!event.relatedTarget || !group.contains(event.relatedTarget)) {
								group.classList.remove('dragActive');
							}
						};

						group.ondrop = event => {
							event.preventDefault();
							group.classList.remove('dragActive');
							const droppedFile = event.dataTransfer.files[0];
							if (droppedFile) {
								fileInput.files = event.dataTransfer.files;
								this.loadFont(droppedFile, index);
							}
						};

						elements[`mute${number}`].onclick = () => {
							this.visibility[index] = !this.visibility[index];
							elements[`mute${number}`].classList.toggle('active', !this.visibility[index]);
							this.draw();
						};
						elements[`solo${number}`].onclick = () => {
							this.solo[index] = !this.solo[index];
							elements[`solo${number}`].classList.toggle('active', this.solo[index]);
							this.draw();
						};
					});
				}

				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
					this.updateThemeColor();
					this.draw();
				}

				updateThemeColor() {
					this.surfaceColor = getComputedStyle(document.documentElement).getPropertyValue('--surface').trim() || '#ffffff';
				}

				fetchUnicodeBlocks() {
					fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://www.unicode.org/Public/latest/ucd/Blocks.txt'))
						.then(response => { if (!response.ok) throw new Error(); return response.text(); })
						.then(text => {
							const ranges = [];
							const regex = /^([0-9A-F]+)\.\.([0-9A-F]+);\s*(.+)$/gm;
							let match;
							while ((match = regex.exec(text)) !== null) {
								ranges.push([parseInt(match[1], 16), parseInt(match[2], 16), match[3]]);
							}
							ranges.length > 0 && (this.unicodeBlocks = ranges, this.layoutCache = [null, null], this.lastBlock = null, this.update());
						})
						.catch(error => console.warn('Block fetch failed', error));
				}

				async loadFont(file, index) {
					const currentSequence = ++this.loadSequence[index];
					this.loadErrors[index] = this.fonts[index] = null;
					this.loading[index] = true;
					this.update();
					try {
						if (!file) return;
						if (file.size > 30 * 1024 * 1024) throw new Error('File too large (max 30MB)');
						const buffer = await file.arrayBuffer();
						if (currentSequence === this.loadSequence[index]) {
							const font = fontkit.create(window.Buffer.from(buffer));
							if (!font.unitsPerEm) throw new Error('Invalid font');
							this.fonts[index] = font;
						}
					} catch (error) {
						currentSequence === this.loadSequence[index] && (this.loadErrors[index] = error.message);
					} finally {
						currentSequence === this.loadSequence[index] && (this.loading[index] = false, this.update());
					}
				}

				getRenderData(index) {
					const number = index + 1;
					const inputs = { font: this.fonts[index], content: elements[`text${number}`].value, fontSize: +elements[`size${number}`].value || 0, letterSpacing: +elements[`spacing${number}`].value || 0, color: elements[`color${number}`].value };
					if (!inputs.font || !inputs.content || !inputs.fontSize) return null;
					const cached = this.renderingCache[index];
					if (cached) {
						const keys = Object.keys(inputs);
						if (keys.every(key => cached.inputs[key] === inputs[key])) return cached.data;
						if (keys.every(key => key === 'color' || cached.inputs[key] === inputs[key]) && cached.data) {
							const context = cached.data.canvas.getContext('2d');
							context.save();
							context.globalCompositeOperation = 'source-in';
							context.fillStyle = inputs.color;
							context.fillRect(0, 0, cached.data.width, cached.data.height);
							context.restore();
							cached.inputs.color = inputs.color;
							return cached.data;
						}
					}
					return this.generateRenderData(index, inputs);
				}

				getScript(char) {
					const code = char.codePointAt(0);
					if (this.lastBlock && code >= this.lastBlock[0] && code <= this.lastBlock[1]) {
						return this.getScriptName(code, this.lastBlock);
					}

					let low = 0, high = this.unicodeBlocks.length - 1;

					while (low <= high) {
						const mid = (low + high) >>> 1;
						const block = this.unicodeBlocks[mid];

						if (code < block[0]) {
							high = mid - 1;
							continue;
						}
						if (code > block[1]) {
							low = mid + 1;
							continue;
						}

						this.lastBlock = block;
						return this.getScriptName(code, block);
					}
					return 'Other';
				}

				getScriptName(code, block) {
					const name = block[2];
					if (name === "Basic Latin") {
						return (code <= 0x40 || (code >= 0x5B && code <= 0x60) || code >= 0x7B) ? 'Common' : 'Latin';
					}

					if (name.includes("Latin")) return 'Latin';
					if (COMMON_SCRIPT_NAMES.has(name)) return 'Common';

					return name;
				}

				generateRenderData(index, inputs) {
					const { font, content, fontSize, letterSpacing, color } = inputs;
					const size = Math.min(Math.max(fontSize, 1), 2000);
					const scale = size / font.unitsPerEm;
					const unit = elements.spacingUnit.value;

					const tracking = unit === 'percent' ? 0 :
									 unit === 'em' ? (letterSpacing / 1000) * font.unitsPerEm :
									 (letterSpacing ? (letterSpacing / size) * font.unitsPerEm : 0);

					const advanceScale = unit === 'percent' ? (letterSpacing / 100) : 1;

					const cachedLayout = this.layoutCache[index];
					const hit = cachedLayout && cachedLayout.content === content && cachedLayout.font === font;
					const runs = hit ? cachedLayout.runs : (() => {
						const segments = [];
						let currentSegment = { text: '', script: null };
						for (const char of content) {
							const script = this.getScript(char);
							if (!currentSegment.script) { currentSegment = { text: char, script: script === 'Common' ? 'Other' : script }; continue; }
							if (script === 'Common' || script === currentSegment.script) { currentSegment.text += char; continue; }
							segments.push(currentSegment);
							currentSegment = { text: char, script };
						}
						currentSegment.text && segments.push(currentSegment);
						const result = segments.map(segment => ({ run: font.layout(segment.text), text: segment.text }));
						this.layoutCache[index] = { content, font, runs: result };
						return result;
					})();

					if (runs.every(r => r.run.glyphs.length === 0)) return null;
					let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, currentX = 0;
					runs.forEach(({ run }) => {
						run.glyphs.forEach((glyph, i) => {
							const position = run.positions[i];
							const boundingBox = glyph.bbox;
							if (boundingBox) {
								const x = currentX + position.xOffset;
								const y = position.yOffset;
								minX = Math.min(minX, x + boundingBox.minX);
								maxX = Math.max(maxX, x + boundingBox.maxX);
								minY = Math.min(minY, y + boundingBox.minY);
								maxY = Math.max(maxY, y + boundingBox.maxY);
							}
							currentX += (position.xAdvance * advanceScale) + tracking;
						});
					});
					if (minX === Infinity) minX = maxX = minY = maxY = 0;
					const metrics = { ascent: Math.max(maxY * scale, (font.ascent || 0) * scale), descent: Math.max(-minY * scale, Math.abs(font.descent || 0) * scale), fontAscent: (font.ascent || 0) * scale, fontDescent: Math.abs(font.descent || 0) * scale, fontCapHeight: (font.capHeight || 0) * scale, fontXHeight: (font.xHeight || 0) * scale, advanceWidth: Math.ceil(currentX * scale) };
					const minXPixel = Math.min(0, minX * scale);
					const maxXPixel = Math.max(metrics.advanceWidth, maxX * scale);
					const drawOffsetX = -minXPixel;
					const width = Math.ceil(maxXPixel - minXPixel);
					const baseline = Math.ceil(metrics.ascent);
					const height = Math.ceil(baseline + metrics.descent);
					if (width > 32767 || height > 32767) throw new Error('Canvas dimensions too large');
					const canvas = this.offscreenCanvases[index];
					canvas.width = Math.max(canvas.width, width);
					canvas.height = Math.max(canvas.height, height);
					const context = canvas.getContext('2d', { willReadFrequently: true });
					context.clearRect(0, 0, width, height);
					context.save();
					context.translate(drawOffsetX, baseline);
					context.scale(1, -1);
					context.fillStyle = color;
					let drawX = 0;
					runs.forEach(({ run }) => {
						run.glyphs.forEach((glyph, i) => {
							const position = run.positions[i];
							context.save();
							context.translate((drawX + position.xOffset) * scale, position.yOffset * scale);
							context.beginPath();
							glyph.render(context, size);
							context.restore();
							drawX += (position.xAdvance * advanceScale) + tracking;
						});
					});
					context.restore();
					const data = { ...this.analyzePixels(context, width, height), ...metrics, drawOffsetX, width, height, canvas, baseline, letterSpacing, fontSize: size, font };
					this.renderingCache[index] = { inputs, data };
					return data;
				}

				analyzePixels(context, width, height) {
					const { data } = context.getImageData(0, 0, width, height);
					const pixelDataInt32 = new Uint32Array(data.buffer);
					const densityByRow = new Float32Array(height);
					let inkPixels = 0, minX = width, maxX = -1, minY = height, maxY = -1;
					const widthMinus3 = width - 3;
					let rowOffset = 0;
					for (let y = 0; y < height; y++) {
						let firstX = -1;
						let ptr = rowOffset;
						let x = 0;
						while (x < widthMinus3) {
							if ((pixelDataInt32[ptr] | pixelDataInt32[ptr + 1] | pixelDataInt32[ptr + 2] | pixelDataInt32[ptr + 3]) === 0) {
								x += 4;
								ptr += 4;
								continue;
							}
							if ((pixelDataInt32[ptr] >>> ALPHA_SHIFT) & 1) { firstX = x; break; }
							if ((pixelDataInt32[ptr + 1] >>> ALPHA_SHIFT) & 1) { firstX = x + 1; break; }
							if ((pixelDataInt32[ptr + 2] >>> ALPHA_SHIFT) & 1) { firstX = x + 2; break; }
							if ((pixelDataInt32[ptr + 3] >>> ALPHA_SHIFT) & 1) { firstX = x + 3; break; }
							x += 4;
							ptr += 4;
						}
						if (firstX === -1) {
							for (; x < width; x++, ptr++) {
								if ((pixelDataInt32[ptr] >>> ALPHA_SHIFT) & 1) {
									firstX = x;
									break;
								}
							}
						}
						if (firstX !== -1) {
							let lastX = -1;
							ptr = rowOffset + width - 1;
							x = width - 1;
							while (x > firstX + 3) {
								if ((pixelDataInt32[ptr] | pixelDataInt32[ptr - 1] | pixelDataInt32[ptr - 2] | pixelDataInt32[ptr - 3]) === 0) {
									x -= 4;
									ptr -= 4;
									continue;
								}
								if ((pixelDataInt32[ptr] >>> ALPHA_SHIFT) & 1) { lastX = x; break; }
								if ((pixelDataInt32[ptr - 1] >>> ALPHA_SHIFT) & 1) { lastX = x - 1; break; }
								if ((pixelDataInt32[ptr - 2] >>> ALPHA_SHIFT) & 1) { lastX = x - 2; break; }
								if ((pixelDataInt32[ptr - 3] >>> ALPHA_SHIFT) & 1) { lastX = x - 3; break; }
								x -= 4;
								ptr -= 4;
							}
							if (lastX === -1) {
								for (; x > firstX; x--, ptr--) {
									if ((pixelDataInt32[ptr] >>> ALPHA_SHIFT) & 1) {
										lastX = x;
										break;
									}
								}
							}
							if (lastX === -1) lastX = firstX;
							let rowInk = 1;
							if (lastX > firstX) {
								rowInk = 2;
								ptr = rowOffset + firstX + 1;
								const endPtr = rowOffset + lastX;
								for (; ptr < endPtr; ptr++) {
									rowInk += (pixelDataInt32[ptr] >>> ALPHA_SHIFT) & 1;
								}
							}
							inkPixels += rowInk;
							densityByRow[y] = rowInk;
							if (y < minY) minY = y;
							maxY = y;
							if (firstX < minX) minX = firstX;
							if (lastX > maxX) maxX = lastX;
						}
						rowOffset += width;
					}
					return { densityByRow, inkPixels, minX, maxX, minY, maxY };
				}

				updateSpacingLabels() {
					const unit = elements.spacingUnit.value;
					const label = unit === 'percent' ? 'Tracking (%)' : unit === 'em' ? 'Letter Spacing (‰ em)' : 'Letter Spacing (px)';
					const defaultVal = unit === 'percent' ? 100 : 0;
					[1, 2].forEach(n => {
						const input = elements[`spacing${n}`];
						const prevLabel = input.parentElement.firstChild;
						prevLabel.textContent = label;
						input.value = defaultVal;
					});
				}

				update() {
					this.analyses = [1, 2].map((number, index) => {
						elements[`dot${number}`].style.backgroundColor = elements[`color${number}`].value;
						try {
							const data = this.getRenderData(index);
							if (!data) return null;
							const hasInk = data.maxY >= data.minY;
							const area = Math.max(1, elements.density.value === 'ink' ? (hasInk ? (data.maxX - data.minX + 1) * (data.maxY - data.minY + 1) : 1) : Math.max(1, data.advanceWidth) * (data.ascent + data.descent));
							return { ...data, baselineShift: +elements[`shift${number}`].value || 0, density: ((data.inkPixels / area) * 100).toFixed(1), yMin: hasInk ? Math.round(data.baseline - data.maxY) : 0, yMax: hasInk ? Math.round(data.baseline - data.minY) : 0 };
						} catch (error) { return { error: error.message }; }
					});
					this.draw();
					[1, 2].forEach((number, index) => this.updateResult(number, index));
				}

				draw() {
					const isVisible = (index) => this.solo.some(s => s) ? this.solo[index] : this.visibility[index];
					const validAnalyses = this.analyses.filter((analysis, index) => analysis && !analysis.error && isVisible(index));
					if (!validAnalyses.length) { this.context.canvas.height = 150; this.updateScale(); return; }
					const sideMode = elements.render.value === 'side' && validAnalyses.length > 1;
					const max = callback => Math.max(0, ...validAnalyses.map(callback));
					const maxAscent = max(item => item.baseline + item.baselineShift);
					const maxDescent = max(item => item.height - item.baseline - item.baselineShift);
					const maxOffsetX = max(item => item.drawOffsetX);
					const totalWidth = sideMode ? validAnalyses.reduce((total, item) => total + item.width, 0) : maxOffsetX + max(item => item.width - item.drawOffsetX);
					const dimensions = { width: Math.ceil(this.graphWidth + this.graphPadding + totalWidth), height: Math.ceil(maxAscent + maxDescent), baseline: Math.ceil(maxAscent), maxDrawOffsetX: maxOffsetX };
					this.context.canvas.width = dimensions.width;
					this.context.canvas.height = dimensions.height;
					this.context.fillStyle = this.surfaceColor;
					this.context.fillRect(0, 0, dimensions.width, dimensions.height);
					const compositeCanvas = this.compositeCanvas;
					compositeCanvas.width = dimensions.width;
					compositeCanvas.height = dimensions.height;
					const compositeCtx = compositeCanvas.getContext('2d');
					compositeCtx.fillStyle = '#ffffff';
					compositeCtx.fillRect(0, 0, dimensions.width, dimensions.height);

					let currentTranslateX = this.graphWidth + this.graphPadding + (sideMode ? 0 : dimensions.maxDrawOffsetX);
					this.analyses.forEach((analysis, index) => {
						if (!analysis || analysis.error || !isVisible(index)) return;
						const y = dimensions.baseline - analysis.baseline - analysis.baselineShift;

						// Draw density graph on composite buffer
						compositeCtx.save();
						compositeCtx.globalCompositeOperation = 'multiply';
						compositeCtx.fillStyle = elements[`color${index + 1}`].value;
						compositeCtx.beginPath();
						const scale = this.graphWidth / Math.max(1, ...analysis.densityByRow);
						let currentWidth = 0, startY = -1;
						for (let rowY = 0; rowY < analysis.densityByRow.length; rowY++) {
							const barWidth = analysis.densityByRow[rowY] ? analysis.densityByRow[rowY] * scale : 0;
							if (barWidth !== currentWidth) {
								if (currentWidth > 0) compositeCtx.rect(this.graphWidth - currentWidth, startY + y, currentWidth, rowY - startY);
								currentWidth = barWidth; startY = rowY;
							}
						}
						if (currentWidth > 0) compositeCtx.rect(this.graphWidth - currentWidth, startY + y, currentWidth, analysis.densityByRow.length - startY);
						compositeCtx.fill();

						// Draw glyphs on composite buffer
						const drawX = sideMode ? currentTranslateX + (analysis.drawOffsetX || 0) : currentTranslateX;
						compositeCtx.drawImage(analysis.canvas, 0, 0, analysis.width, analysis.height, drawX - (analysis.drawOffsetX || 0), y, analysis.width, analysis.height);
						compositeCtx.restore();

						if (sideMode) currentTranslateX += analysis.width;
					});

					// Convert white background to transparency
					const imageData = compositeCtx.getImageData(0, 0, dimensions.width, dimensions.height);
					const data = imageData.data;
					const buf32 = new Uint32Array(data.buffer);
					const len = buf32.length;
					if (isLittleEndianArchitecture) {
						for (let i = 0; i < len; i++) {
							const val = buf32[i];
							if (val === 0xFFFFFFFF) {
								buf32[i] = 0x00FFFFFF;
								continue;
							}
							const r = val & 0xFF;
							const g = (val >>> 8) & 0xFF;
							const b = (val >>> 16) & 0xFF;
							let min = r;
							if (g < min) min = g;
							if (b < min) min = b;
							const alpha = 255 - min;
							if (alpha > 0) {
								const factor = 255 / alpha;
								const idx = i << 2;
								data[idx] = 255 - (255 - r) * factor;
								data[idx + 1] = 255 - (255 - g) * factor;
								data[idx + 2] = 255 - (255 - b) * factor;
								data[idx + 3] = alpha;
							} else {
								buf32[i] = val & 0x00FFFFFF;
							}
						}
					} else {
						for (let i = 0; i < len; i++) {
							if (buf32[i] === 0xFFFFFFFF) {
								data[(i << 2) + 3] = 0;
								continue;
							}
							const idx = i << 2;
							const r = data[idx], g = data[idx + 1], b = data[idx + 2];
							let min = r;
							if (g < min) min = g;
							if (b < min) min = b;
							const alpha = 255 - min;
							data[idx + 3] = alpha;
							if (alpha > 0) {
								const factor = 255 / alpha;
								data[idx] = 255 - (255 - r) * factor;
								data[idx + 1] = 255 - (255 - g) * factor;
								data[idx + 2] = 255 - (255 - b) * factor;
							}
						}
					}
					compositeCtx.putImageData(imageData, 0, 0);
					this.context.drawImage(compositeCanvas, 0, 0);
					const guides = elements.guides.value;
					if (['baseline', 'metrics'].includes(guides)) {
						this.context.fillStyle = 'rgba(255, 0, 0, 0.5)';
						this.context.fillRect(0, dimensions.baseline, this.context.canvas.width, 1);
					}
					if (guides === 'metrics') {
						validAnalyses.forEach((analysis, index) => {
							const y = dimensions.baseline - analysis.baselineShift;
							this.context.fillStyle = elements[`color${index + 1}`].value;
							this.context.globalAlpha = 0.5;
							this.context.fillRect(0, Math.floor(y - analysis.fontAscent), this.context.canvas.width, 1);
							this.context.fillRect(0, Math.floor(y + analysis.fontDescent), this.context.canvas.width, 1);
							this.context.globalAlpha = 0.3;
							this.context.fillRect(0, Math.floor(y - analysis.fontCapHeight), this.context.canvas.width, 1);
							this.context.fillRect(0, Math.floor(y - analysis.fontXHeight), this.context.canvas.width, 1);
							this.context.globalAlpha = 1.0;
						});
					}
					this.updateScale();
				}

				updateScale() {
					const { canvas, container, preview } = elements;
					canvas.style.transform = 'none';
					container.style.width = container.style.height = container.style.overflow = '';
					if (elements.zoom.value !== 'fit' || !canvas.width) return;
					const style = getComputedStyle(container);
					const scale = Math.min((preview.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight)) / canvas.width, 1);
					canvas.style.transform = `scale(${scale})`;
					container.style.width = `${canvas.width * scale + parseFloat(style.paddingLeft) + parseFloat(style.paddingRight)}px`;
					container.style.height = `${canvas.height * scale + parseFloat(style.paddingTop) + parseFloat(style.paddingBottom)}px`;
					container.style.overflow = 'hidden';
				}

				updateResult(number, index) {
					const analysis = this.analyses[index];
					const error = this.loadErrors[index] || (analysis && analysis.error);
					const message = error ? `Error: ${error}` : !this.fonts[index] ? 'Load font.' : !analysis ? 'Enter text.' : '';
					const name = this.fonts[index] ? (this.fonts[index].fullName || `Font ${number}`) : `Font ${number}`;
					elements[`name${number}`].textContent = elements[`name${number}`].title = name;
					elements[`analysisName${number}`].textContent = elements[`analysisName${number}`].title = `${name} Analysis`;
					elements[`color${number}`].setAttribute('aria-label', `${name} Color`);
					elements[`analysisName${number}`].nextElementSibling.setAttribute('aria-label', `Copy ${name} analysis`);

					if (this.loading[index]) {
						elements[`result${number}`].innerHTML = '<div class="spinner" aria-label="Loading"></div>';
						return;
					}
					if (message) {
						elements[`result${number}`].innerHTML = `<div class="state-message">${message}</div>`;
						return;
					}

					elements[`result${number}`].innerHTML = `<div class="statisticGrid">${row('Density', analysis.density + '%')}<div class="statisticGroup"><div class="statisticTitle">Ink Bounds</div>${row('Max Y', analysis.yMax)}${row('Min Y', analysis.yMin)}</div><div class="statisticGroup"><div class="statisticTitle">Metrics</div>${row('Ascent', Math.round(analysis.fontAscent))}${row('Cap Height', Math.round(analysis.fontCapHeight))}${row('x-Height', Math.round(analysis.fontXHeight))}${row('Descent', '-' + Math.round(analysis.fontDescent))}</div></div>`;
				}
			}
			new DensityTool();
		</script>
	</body>
</html>
