<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Typographic Density Tool</title>
		<script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
		<style>
			:root {
				--primary: #0070ea;
				--primary-hover: #005bc0;
				--bg: #f7f7f8;
				--bg-container: #fff;
				--text: #333;
				--border: #e0e0e0;
				--panel: #fdfdfd;
				--font1: rgba(0,162,162,0.9);
				--font2: rgba(255,0,255,0.9);
				--input-bg: #fff
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--bg: #10131b;
					--bg-container: #181c23;
					--text: #c1c6d7;
					--border: #414754;
					--panel: #1a1e26;
					--input-bg: #0f1218
				}
			}

			:root.dark {
				--bg: #10131b;
				--bg-container: #181c23;
				--text: #c1c6d7;
				--border: #414754;
				--panel: #1a1e26;
				--input-bg: #0f1218
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--bg);
				color: var(--text);
				font-family: sans-serif;
				line-height: 1.6;
				padding: 24px
			}

			.header {
				text-align: center;
				margin-bottom: 32px
			}

			.header h1 {
				font-size: 2em;
				font-weight: 600
			}

			.container {
				display: grid;
				grid-template-columns: 360px 1fr;
				gap: 24px;
				max-width: 1500px;
				margin: 0 auto
			}

			.panel {
				background: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 24px;
				min-width: 0
			}

			.panel-title {
				margin: 0 0 24px;
				font-size: 1.2em;
				font-weight: 600;
				border-bottom: 1px solid var(--border);
				padding-bottom: 12px
			}

			.font-section,.result-card {
				padding: 16px;
				border-radius: 6px;
				background: var(--panel);
				border: 1px solid var(--border)
			}

			.font-section {
				margin-bottom: 20px
			}

			.font-header,.result-header {
				display: flex;
				align-items: center;
				font-weight: 600
			}

			.font-header {
				margin: 0 0 16px
			}

			.color-indicator {
				width: 16px;
				height: 16px;
				border-radius: 4px;
				margin-right: 10px;
				flex: 0 0 16px
			}

			.font1 .color-indicator {
				background: var(--font1)
			}

			.font2 .color-indicator {
				background: var(--font2)
			}

			.form-group {
				margin-bottom: 16px
			}

			.form-group:last-child {
				margin-bottom: 0
			}

			.form-label {
				display: block;
				font-weight: 500;
				margin-bottom: 6px;
				font-size: .9em;
				color: var(--text);
				opacity: .85
			}

			.form-control,.controls-bar>* {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid var(--border);
				border-radius: 4px;
				font-size: .95em;
				background: var(--input-bg);
				color: var(--text);
				transition: border-color .2s,box-shadow .2s
			}

			.controls-bar>* {
				width: auto;
				padding: 6px 10px;
				font-size: .9em
			}

			.form-control:focus {
				outline: none;
				border-color: var(--primary);
				box-shadow: 0 0 0 3px rgba(0,112,234,.15)
			}

			textarea.form-control {
				min-height: 80px;
				resize: vertical
			}

			.form-row {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 12px
			}

			.controls-bar {
				display: flex;
				align-items: center;
				gap: 12px;
				margin-bottom: 16px;
				flex-wrap: wrap
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			button:hover {
				opacity: .9
			}

			.btn-primary {
				background: var(--primary);
				border: none;
				color: #fff
			}

			.btn-primary:hover {
				background: var(--primary-hover)
			}

			.preview-container {
				background: var(--input-bg);
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto
			}

			.canvas-wrapper {
				padding: 20px;
				display: flex;
				justify-content: flex-start;
				align-items: center
			}

			#canvas {
				display: block;
				transform-origin: top left
			}

			.results-section {
				margin-top: 24px
			}

			.results-grid {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 16px
			}

			.result-header {
				margin: 0 0 10px
			}

			.result-data {
				font-family: monospace;
				font-size: .95em;
				line-height: 1.5;
				color: var(--text);
				background: var(--panel);
				padding: 10px;
				border-radius: 4px;
				white-space: pre-wrap;
				opacity: .9
			}

			.theme-select {
				position: absolute;
				right: 24px;
				top: 24px
			}

			.theme-select select {
				font-size: .9rem;
				padding: 5px;
				width: auto;
				background: var(--bg-container);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text)
			}

			@media(max-width: 900px) {
				.container {
					grid-template-columns: 1fr
				}
			}

			@media(max-width: 500px) {
				.results-grid {
					grid-template-columns: 1fr
				}
				body {
					padding: 16px
				}
				.theme-select {
					right: 16px;
					top: 16px
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>Typographic Density Tool</h1>
			<div class="theme-select">
				<select id="themeSelect">
					<option value="auto">Auto Theme</option>
					<option value="light">Light</option>
					<option value="dark">Dark</option>
				</select>
			</div>
		</div>
		<div class="container">
			<div class="panel">
				<h2 class="panel-title">Font Configuration</h2>
				<div class="font-section font1">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 1 (Cyan)
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-file">Font File</label>
						<input type="file" id="font1-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-text">Text</label>
						<textarea id="font1-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Idealogy</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-size">Size (px)</label>
						<input type="number" id="font1-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font1-letter-spacing">Letter Spacing</label>
							<input type="number" id="font1-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font1-shift">Baseline Shift</label>
							<input type="number" id="font1-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
				<div class="font-section font2">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 2 (Magenta)
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-file">Font File</label>
						<input type="file" id="font2-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-text">Text</label>
						<textarea id="font2-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Идеология</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-size">Size (px)</label>
						<input type="number" id="font2-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font2-letter-spacing">Letter Spacing</label>
							<input type="number" id="font2-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font2-shift">Baseline Shift</label>
							<input type="number" id="font2-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
			</div>
			<div class="panel">
				<h2 class="panel-title">Visualization and Analysis</h2>
				<div class="controls-bar">
					<select id="zoom-mode">
						<option value="fit">Fit to View</option>
						<option value="100">100% Scale</option>
					</select>
					<select id="render-mode">
						<option value="overlay">Overlay</option>
						<option value="side-by-side">Side-by-side</option>
					</select>
					<select id="density-mode">
						<option value="ink-box">Ink Box</option>
						<option value="em-box">Em box</option>
					</select>
					<button id="export-png" class="btn-primary" style="margin-left: auto;">Export PNG</button>
				</div>
				<div class="preview-container">
					<div class="canvas-wrapper">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results-section">
					<div class="results-grid">
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font1)"></div>
								Font 1 Analysis
							</div>
							<div id="results1" class="result-data">Load a font to see analysis.</div>
						</div>
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font2)"></div>
								Font 2 Analysis
							</div>
							<div id="results2" class="result-data">Load a font to see analysis.</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script>
			const $ = id=>document.getElementById(id);

			class DensityTool {
				constructor() {
					this.state = {
						fonts: [null, null],
						analyses: [null, null],
						animRefs: {},
						theme: "auto",
						graphWidth: 150,
						graphPadding: 20,
					};

					this.ui = {
						canvas: $("canvas"),
						zoomMode: $("zoom-mode"),
						renderMode: $("render-mode"),
						densityMode: $("density-mode"),
						exportPng: $("export-png"),
						themeSelect: $("themeSelect"),
						fontUIs: [1, 2].map(i => ({
							file: $(`font${i}-file`),
							text: $(`font${i}-text`),
							size: $(`font${i}-size`),
							shift: $(`font${i}-shift`),
							letterSpacing: $(`font${i}-letter-spacing`),
							results: $(`results${i}`),
						})),
					};

					const cs = getComputedStyle(document.documentElement);
					this.colors = ["--font1", "--font2"].map(p => cs.getPropertyValue(p).trim());
					this.ctx = this.ui.canvas.getContext("2d");

					this.bindEvents();
					this.applyTheme();
					this.render();
			}

				bindEvents() {
					const queue = (fn, key) => (...args) => {
						cancelAnimationFrame(this.state.animRefs[key]);
						this.state.animRefs[key] = requestAnimationFrame(() => fn(...args));
					};

					this.requestAnalysis = queue(() => this.analyzeAndRender(), "analyze");
					this.requestScaling = queue(() => this.updateDisplayScale(), "scale");

					this.ui.zoomMode.onchange = this.requestScaling;
					this.ui.renderMode.onchange = this.requestAnalysis;
					this.ui.densityMode.onchange = this.requestAnalysis;
					this.ui.exportPng.onclick = () => this.exportPNG();
					this.ui.themeSelect.onchange = e => {
						this.state.theme = e.target.value;
						this.applyTheme();
					};

					this.ui.fontUIs.forEach((ui, i) => {
						ui.file.onchange = e => this.loadFont(e.target.files?.[0], i);
						["text", "size", "shift", "letterSpacing"].forEach(prop => {
							ui[prop].oninput = this.requestAnalysis;
						});
					});
					window.onresize = this.requestScaling;
				}

				applyTheme() {
					document.documentElement.classList.remove("light", "dark");
					if (this.state.theme !== "auto") {
						document.documentElement.classList.add(this.state.theme);
					}
				}
				async loadFont(file, index) {
					const ui = this.ui.fontUIs[index];
					const MAX_SIZE_MB = 30;
					let font = null;
					try {
						if (!file) return;
						if (file.size > MAX_SIZE_MB * 1024 * 1024) {
							throw new Error(`File exceeds ${MAX_SIZE_MB}MB`);
						}
						const buffer = await file.arrayBuffer();
						font = opentype.parse(buffer);
						if (!font?.draw || !font.unitsPerEm) throw new Error("Invalid or unsupported font file.");
					} catch (err) {
						alert(`Error loading font: ${err.message}`);
						console.error("Font loading failed:", err);
						ui.file.value = "";
					} finally {
						this.state.fonts[index] = font;
						this.requestAnalysis();
					}
				}
				getFontMetrics(font, text, fontSize, letterSpacing) {
					if (!font.unitsPerEm) throw new Error("Invalid font data: missing unitsPerEm.");
					const scale = fontSize / font.unitsPerEm;
					const options = { tracking: letterSpacing || 0 };
					const path = font.getPath(text, 0, 0, fontSize, options);
					const { x1, y1, x2, y2 } = path.getBoundingBox();

					const { os2, hhea } = font.tables;
					const getMaxMetric = (keys, mapper = v => v) => Math.max(...keys.map(k => mapper(font[k] ?? os2?.[k] ?? hhea?.[k] ?? 0)));
					const fontAscent = getMaxMetric(["ascender", "sTypoAscender", "usWinAscent"]) * scale;
					const fontDescent = Math.abs(getMaxMetric(["descender", "sTypoDescender", "usWinDescent"])) * scale;

					return {
						ascent: Math.max(y2, fontAscent),
						descent: Math.max(-y1, fontDescent),
						actualAscent: y2,
						actualDescent: -y1,
						fontAscent,
						fontDescent,
						bboxWidth: Math.ceil(x2 - x1),
						advanceWidth: Math.ceil(font.getAdvanceWidth(text, fontSize, options)),
					};
				}

				analyzeFont(font, text, fontSize, baselineShift, letterSpacing, color) {
					if (!font || !text || !fontSize) return null;

					const finalSize = Math.max(1, Math.min(fontSize, 2000));
					const metrics = this.getFontMetrics(font, text, finalSize, letterSpacing);
					if (!isFinite(metrics.advanceWidth) || metrics.advanceWidth <= 0) return null;

					const textCanvas = document.createElement("canvas");
					const baseline = Math.ceil(metrics.ascent);
					textCanvas.width = metrics.advanceWidth;
					textCanvas.height = Math.ceil(metrics.ascent + metrics.descent);
					font.draw(textCanvas.getContext("2d"), text, 0, baseline, finalSize, { tracking: letterSpacing || 0 });

					const pixelData = this.getPixelData(textCanvas);
					if (pixelData.minY > pixelData.maxY) return null;

					const tintedTextCanvas = this.tintCanvas(textCanvas, color);
					const graphCanvas = this.drawDensityGraph(pixelData.densityMap, color, textCanvas.height);

					return {
						...pixelData,
						...metrics,
						textCanvas: tintedTextCanvas,
						graphCanvas,
						baseline,
						baselineShift,
						letterSpacing,
						fontSize: finalSize,
						density: this.calculateDensity(pixelData, metrics, finalSize).toFixed(1),
						yMin: Math.round(baseline - pixelData.maxY),
						yMax: Math.round(baseline - pixelData.minY),
					};
				}
				getPixelData(canvas) {
					const { width, height } = canvas;
					const { data } = canvas.getContext("2d", { willReadFrequently: true }).getImageData(0, 0, width, height);
					const densityMap = new Float32Array(height);
					let inkVolume = 0, minX = width, maxX = -1, minY = height, maxY = -1;

					for (let i = 3; i < data.length; i += 4) {
						if (data[i] >= 128) {
							const pixelIndex = (i - 3) / 4;
							const y = Math.floor(pixelIndex / width);
							const x = pixelIndex % width;
							minY = Math.min(minY, y);
							maxY = Math.max(maxY, y);
							minX = Math.min(minX, x);
							maxX = Math.max(maxX, x);
							inkVolume++;
							densityMap[y]++;
						}
					}
					return { densityMap, inkVolume, minX, maxX, minY, maxY };
				}

				calculateDensity({ inkVolume, maxX, minX, maxY, minY }, metrics, fontSize) {
					const inkBoxArea = ((maxX - minX + 1) || 1) * ((maxY - minY + 1) || 1);
					const area = this.ui.densityMode.value === "ink-box" ? inkBoxArea : metrics.advanceWidth * fontSize;
					return (inkVolume / area) * 100;
				}
				analyzeAndRender() {
					this.state.analyses = this.ui.fontUIs.map((ui,i)=>this.analyzeFont(this.state.fonts[i], ui.text.value.trim(), +ui.size.value || 0, +ui.shift.value || 0, +ui.letterSpacing.value || 0, this.colors[i]));
					this.render();
					this.updateResults();
				}
				render() {
					const { ctx, ui, state } = this;
					const validAnalyses = state.analyses.filter(Boolean);
					if (validAnalyses.length === 0) return this.renderEmpty();

					const dims = this.calculateDimensions(validAnalyses);
					Object.assign(ui.canvas, dims);
					ctx.clearRect(0, 0, dims.width, dims.height);

					const isSideBySide = ui.renderMode.value === "side-by-side" && validAnalyses.length > 1;
					let x = 0;

					state.analyses.forEach((analysis, i) => {
						if (!analysis) return;
						const y = dims.baseline - analysis.baseline - analysis.baselineShift;
						ctx.globalCompositeOperation = state.analyses.every(Boolean) && i > 0 ? "multiply" : "source-over";
						ctx.drawImage(analysis.graphCanvas, x, y);
						ctx.drawImage(analysis.textCanvas, x + state.graphWidth + state.graphPadding, y);
						if (isSideBySide) x += analysis.textCanvas.width + state.graphWidth + state.graphPadding;
					});

					ctx.globalCompositeOperation = "source-over";
					this.requestScaling();
				}

				calculateDimensions(analyses) {
					const isSideBySide = this.ui.renderMode.value === "side-by-side" && analyses.length > 1;
					const asc = Math.max(0, ...analyses.map(a => a.baseline - a.baselineShift));
					const desc = Math.max(0, ...analyses.map(a => a.textCanvas.height - a.baseline + a.baselineShift));
					const totalW = isSideBySide
						? analyses.reduce((sum, a) => sum + a.textCanvas.width + this.state.graphWidth + this.state.graphPadding, 0)
						: Math.max(0, ...analyses.map(a => a.textCanvas.width + this.state.graphWidth + this.state.graphPadding));

					return {
						width: Math.ceil(totalW),
						height: Math.ceil(asc + desc),
						baseline: Math.ceil(asc),
					};
				}

				drawDensityGraph(densityMap, color, height) {
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");
					const { graphWidth } = this.state;
					canvas.width = graphWidth;
					canvas.height = height;
					const max = Math.max(1, ...densityMap);
					ctx.fillStyle = color;
					densityMap.forEach((val, y) => {
						if (val > 0) {
							const barWidth = (val / max) * graphWidth;
							ctx.fillRect(graphWidth - barWidth, y, barWidth, 1);
						}
					});
					return canvas;
				}

				tintCanvas(canvas, color) {
					const tint = document.createElement("canvas");
					const tintCtx = tint.getContext("2d");
					tint.width = canvas.width;
					tint.height = canvas.height;
					tintCtx.fillStyle = color;
					tintCtx.fillRect(0, 0, tint.width, tint.height);
					tintCtx.globalCompositeOperation = "destination-in";
					tintCtx.drawImage(canvas, 0, 0);
					return tint;
				}

				renderEmpty() {
					this.ui.canvas.width = 400;
					this.ui.canvas.height = 200;
					this.ctx.clearRect(0, 0, 400, 200);
					this.requestScaling();
				}
				updateDisplayScale() {
					const { style, parentElement, width, height } = this.ui.canvas;
					const fitMode = this.ui.zoomMode.value === "fit";
					style.transform = "none";
					Object.assign(parentElement.style, { width: "", height: "", overflow: "" });

					if (!fitMode || !width) return;

					const cs = getComputedStyle(parentElement);
					const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
					const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
					const scale = Math.min((parentElement.parentElement.clientWidth - padX) / width, 1);

					style.transform = `scale(${scale})`;
					Object.assign(parentElement.style, {
						width: `${width * scale + padX}px`,
						height: `${height * scale + padY}px`,
						overflow: "hidden",
					});
				}

				updateResults() {
					this.ui.fontUIs.forEach((ui, i) => {
						const analysis = this.state.analyses[i];
						if (!analysis) {
							ui.results.textContent = this.state.fonts[i] ? "Enter text to analyze." : "Load a font to see analysis.";
							return;
						}
						const formatVal = (key, unit = "px") => `${key.replace(/([A-Z])/g, " $1").replace(/^\w/, c => c.toUpperCase())}: ${Math.round(analysis[key])}${unit}`;
						const metrics = Object.keys(analysis).filter(k => k.includes("Ascent") || k.includes("Descent")).map(k => formatVal(k));
						ui.results.textContent = [
							`Y Min: ${analysis.yMin}px`, `Y Max: ${analysis.yMax}px`, `Density: ${analysis.density}%`,
							`Font Size: ${analysis.fontSize}px`, `Baseline Shift: ${analysis.baselineShift}px`,
							`Letter Spacing: ${analysis.letterSpacing}px`, ...metrics
						].join("\n");
					});
				}

				exportPNG() {
					const link = document.createElement("a");
					link.href = this.ui.canvas.toDataURL("image/png");
					link.download = "typographic-density.png";
					link.click();
				}
			}

			document.addEventListener("DOMContentLoaded", ()=>new DensityTool());
		</script>
	</body>
</html>
