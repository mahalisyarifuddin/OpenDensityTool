<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Typographic Density Tool</title>
		<script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
		<style>
			:root {
				--bg: #f7f7f8;
				--text: #333;
				--border: #e0e0e0;
				--panel: #ffffff;
				--accent: #0066cc;
				--font1: rgba(0, 162, 162, 0.9);
				--font2: rgba(255, 0, 255, 0.9);
			}

			* {
				box-sizing: border-box;
			}

			body {
				font-family: sans-serif;
				margin: 0;
				padding: 24px;
				background: var(--bg);
				color: var(--text);
				line-height: 1.6;
			}

			.header {
				text-align: center;
				margin-bottom: 32px;
			}

			.header h1 {
				margin: 0;
				font-size: 2em;
				font-weight: 600;
			}

			.container {
				display: grid;
				grid-template-columns: 360px 1fr;
				gap: 24px;
				max-width: 1500px;
				margin: 0 auto;
			}

			.panel {
				background: var(--panel);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 24px;
				min-width: 0;
			}

			.panel-title {
				margin: 0 0 24px;
				font-size: 1.2em;
				font-weight: 600;
				border-bottom: 1px solid var(--border);
				padding-bottom: 12px;
			}

			.font-section,
			.result-card {
				padding: 16px;
				border-radius: 6px;
				background: #fdfdfd;
				border: 1px solid var(--border);
			}

			.font-section {
				margin-bottom: 20px;
			}

			.font-header,
			.result-header {
				display: flex;
				align-items: center;
				font-weight: 600;
			}

			.font-header {
				margin: 0 0 16px;
			}

			.color-indicator {
				width: 16px;
				height: 16px;
				border-radius: 4px;
				margin-right: 10px;
				flex: 0 0 16px;
			}

			.font1 .color-indicator {
				background: var(--font1);
			}

			.font2 .color-indicator {
				background: var(--font2);
			}

			.form-group {
				margin-bottom: 16px;
			}

			.form-group:last-child {
				margin-bottom: 0;
			}

			.form-label {
				display: block;
				font-weight: 500;
				margin-bottom: 6px;
				font-size: 0.9em;
				color: #555;
			}

			.form-control, .controls-bar > * {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid #ccc;
				border-radius: 4px;
				font-size: 0.95em;
				background: #fff;
				transition: border-color .2s,box-shadow .2s;
			}

			.controls-bar > * {
				width: auto;
				padding: 6px 10px;
				font-size: 0.9em;
			}

			.form-control:focus {
				outline: none;
				border-color: var(--accent);
				box-shadow: 0 0 0 3px rgba(0,102,204,.15);
			}

			textarea.form-control {
				min-height: 80px;
				resize: vertical;
			}

			.form-row {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 12px;
			}

			.controls-bar {
				display: flex;
				align-items: center;
				gap: 12px;
				margin-bottom: 16px;
				flex-wrap: wrap;
			}

			.preview-container {
				background: #fff;
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto;
			}

			.canvas-wrapper {
				padding: 20px;
				display: flex;
				justify-content: flex-start;
				align-items: flex-start;
			}

			#canvas {
				display: block;
				transform-origin: top left;
			}

			.results-section {
				margin-top: 24px;
			}

			.results-grid {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 16px;
			}


			.result-header {
				margin: 0 0 10px;
			}

			.result-data {
				font-family: monospace;
				font-size: 0.95em;
				line-height: 1.5;
				color: #444;
				background: #f0f0f0;
				padding: 10px;
				border-radius: 4px;
				white-space: pre-wrap;
			}

			@media (max-width: 900px) {
				.container {
					grid-template-columns:1fr;
				}
			}

			@media (max-width: 500px) {
				.results-grid {
					grid-template-columns:1fr;
				}

				body {
					padding: 16px;
				}
			}
		</style>
	</head>
	<body>
		<h1 class="header">Typographic Density Tool</h1>
		<div class="container">
			<div class="panel">
				<h2 class="panel-title">Font Configuration</h2>
				<div class="font-section font1">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 1 (Cyan)
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-file">Font File</label>
						<input type="file" id="font1-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-text">Text</label>
						<textarea id="font1-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Idealogy</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-size">Size (px)</label>
						<input type="number" id="font1-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font1-letter-spacing">Letter Spacing</label>
							<input type="number" id="font1-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font1-shift">Baseline Shift</label>
							<input type="number" id="font1-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
				<div class="font-section font2">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 2 (Magenta)
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-file">Font File</label>
						<input type="file" id="font2-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-text">Text</label>
						<textarea id="font2-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Идеология</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-size">Size (px)</label>
						<input type="number" id="font2-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font2-letter-spacing">Letter Spacing</label>
							<input type="number" id="font2-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font2-shift">Baseline Shift</label>
							<input type="number" id="font2-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
			</div>
			<div class="panel">
				<h2 class="panel-title">Visualization and Analysis</h2>
				<div class="controls-bar">
					<select id="zoom-mode">
						<option value="fit">Fit to View</option>
						<option value="100">100% Scale</option>
					</select>
					<select id="render-mode">
						<option value="overlay">Overlay</option>
						<option value="side-by-side">Side-by-side</option>
					</select>
					<select id="density-mode">
						<option value="ink-box">Ink Box</option>
						<option value="em-box">Em box</option>
					</select>
					<button id="export-png" style="margin-left: auto;">Export PNG</button>
				</div>
				<div class="preview-container">
					<div class="canvas-wrapper">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results-section">
					<div class="results-grid">
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font1)"></div>
								Font 1 Analysis
							</div>
							<div id="results1" class="result-data">Load a font to see analysis.</div>
						</div>
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font2)"></div>
								Font 2 Analysis
							</div>
							<div id="results2" class="result-data">Load a font to see analysis.</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script>
			const $ = (id) => document.getElementById(id);

			class DensityTool {
				constructor() {
					this._initialize();
					this._bindEvents();
					this.render();
				}

				_initialize() {
					const ui = (this.ui = this.getUIElements());
					const tintCanvas = document.createElement('canvas');
					const tintContext = tintCanvas.getContext('2d', { willReadFrequently: true });
					const fontUIs = [1, 2].map(i => ({
						file: ui[`font${i}File`], text: ui[`font${i}Text`], size: ui[`font${i}Size`],
						shift: ui[`font${i}Shift`], letterSpacing: ui[`font${i}LetterSpacing`], results: ui[`results${i}`]
					}));

					Object.assign(this, {
						colors: ['--font1', '--font2'].map(p => getComputedStyle(document.documentElement).getPropertyValue(p).trim()),
						graphWidth: 150,
						graphPadding: 20,
						fonts: [null, null],
						analyses: [null, null],
						animRefs: {},
						tintCanvas,
						tintContext,
						fontUIs,
						ctx: ui.canvas.getContext('2d'),
					});
				}

				getUIElements() {
					const ui = {};
					const ids = [
						'canvas', 'zoom-mode', 'render-mode', 'density-mode', 'export-png',
						...[1, 2].flatMap(i => [`font${i}-file`, `font${i}-text`, `font${i}-size`, `font${i}-shift`, `font${i}-letter-spacing`, `results${i}`])
					];
					ids.forEach(id => ui[id.replace(/-(\w)/g, (_, c) => c.toUpperCase())] = $(id));
					return ui;
				}

				_bindEvents() {
					const queue = (fn, key) => (...args) => {
						cancelAnimationFrame(this.animRefs[key]);
						this.animRefs[key] = requestAnimationFrame(() => fn.apply(this, args));
					};
					this.requestAnalysis = queue(this.analyzeAndRender, 'analyze');
					this.requestScaling = queue(this.updateDisplayScale, 'scale');

					const eventMap = {
						'zoom-mode': { event: 'change', handler: this.requestScaling },
						'render-mode': { event: 'change', handler: this.requestAnalysis },
						'density-mode': { event: 'change', handler: this.requestAnalysis },
						'export-png': { event: 'click', handler: this.exportPNG },
					};

					for (const id in eventMap) {
						$(id).addEventListener(eventMap[id].event, eventMap[id].handler.bind(this));
					}

					this.fontUIs.forEach((ui, i) => {
						ui.file.addEventListener('change', e => this.loadFont(e.target.files?.[0], i));
						['text', 'size', 'shift', 'letterSpacing'].forEach(prop => {
							['input', 'change'].forEach(evt => ui[prop].addEventListener(evt, this.requestAnalysis));
						});
					});

					window.addEventListener('resize', this.requestScaling);
				}

				async loadFont(file, index) {
					let font = null;
					const ui = this.fontUIs[index];
					const MAX_SIZE_MB = 30;
					const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;

					if (file) {
						if (file.size > MAX_SIZE_BYTES) {
							alert(`Font file is too large (${(file.size / 1048576).toFixed(1)}MB). Max size is ${MAX_SIZE_MB}MB.`);
						} else {
							try {
								font = opentype.parse(await file.arrayBuffer());
							} catch (err) {
								console.error('Font loading failed:', err);
								alert(`Failed to parse font: ${file.name}.`);
							}
						}
					}

					this.fonts[index] = font;
					if (!font) {
						ui.file.value = '';
					}
					this.requestAnalysis();
				}

				analyzeAndRender() {
					this.analyses = this.fontUIs.map((ui, i) =>
						this.analyzeFont(this.fonts[i], ui.text.value.trim(), +ui.size.value || 0, +ui.shift.value || 0, +ui.letterSpacing.value || 0)
					);
					this.render();
				}

				exportPNG() {
					const link = document.createElement('a');
					link.href = this.ui.canvas.toDataURL('image/png');
					link.download = 'typographic-density.png';
					link.click();
				}

				analyzeFont(font, text, fontSize, baselineShift, letterSpacing) {
					if (!font || !text || !fontSize) return null;
					const finalSize = Math.max(1, Math.min(fontSize, 2000));
					const metrics = this.getFontMetrics(font, text, finalSize, letterSpacing);

					if (!isFinite(metrics.advanceWidth) || metrics.advanceWidth <= 0) return null;

					const height = Math.ceil(metrics.ascent + metrics.descent);
					const baseline = Math.ceil(metrics.ascent);
					const canvas = Object.assign(document.createElement('canvas'), { width: metrics.advanceWidth, height });
					font.draw(canvas.getContext('2d'), text, 0, baseline, finalSize, { tracking: letterSpacing || 0 });
					const pixelData = this.getPixelData(canvas);

					if (pixelData.minY > pixelData.maxY) return null;
					return {
						...pixelData, ...metrics, canvas, baseline, baselineShift, letterSpacing, fontSize: finalSize, font,
						density: this._calculateDensity(pixelData, metrics, finalSize).toFixed(1),
						yMin: Math.round(baseline - pixelData.maxY), yMax: Math.round(baseline - pixelData.minY),
					};
				}

				getFontMetrics(font, text, fontSize, letterSpacing) {
					const scale = fontSize / font.unitsPerEm;
					const glyphs = font.stringToGlyphs(text);
					const { actualAscent, actualDescent } = glyphs.reduce((acc, g) => {
						const b = g.path?.getBoundingBox();
						if (b && isFinite(b.y1) && isFinite(b.y2)) {
							acc.actualAscent = Math.max(acc.actualAscent, b.y2);
							acc.actualDescent = Math.max(acc.actualDescent, -b.y1);
						}
						return acc;
					}, { actualAscent: 0, actualDescent: 0 });

					const { os2, hhea } = font.tables;
					const getMaxMetric = (keys, mapper = v => v) => Math.max(...keys.map(k => mapper(font[k] || os2?.[k] || hhea?.[k] || 0)));

					const fontAscent = getMaxMetric(['ascender', 'sTypoAscender', 'usWinAscent']) * scale;
					const fontDescent = getMaxMetric(['descender', 'sTypoDescender', 'usWinDescent'], Math.abs) * scale;
					const scaledAscent = actualAscent * scale || font.ascender * scale;
					const scaledDescent = actualDescent * scale || Math.abs(font.descender * scale);

					const options = { tracking: letterSpacing || 0 };
					const path = font.getPath(text, 0, 0, fontSize, options);
					return {
						ascent: Math.max(scaledAscent, fontAscent), descent: Math.max(scaledDescent, fontDescent),
						actualAscent: scaledAscent, actualDescent: scaledDescent, fontAscent, fontDescent,
						bboxWidth: Math.ceil(path.getBoundingBox().x2 - path.getBoundingBox().x1),
						advanceWidth: Math.ceil(font.getAdvanceWidth(text, fontSize, options)),
					};
				}

				getPixelData(canvas) {
					const { data, width, height } = canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, canvas.width, canvas.height);
					const densityMap = new Float32Array(height);
					let inkVolume = 0, minX = width, maxX = -1, minY = height, maxY = -1;

					for (let y = 0; y < height; y++) {
						for (let x = 0, i = y * width * 4 + 3; x < width; x++, i += 4) {
							if (data[i] >= 128) {
								minY = Math.min(minY, y); maxY = Math.max(maxY, y);
								minX = Math.min(minX, x); maxX = Math.max(maxX, x);
								inkVolume++;
								densityMap[y]++;
							}
						}
					}
					return { densityMap, inkVolume, minX, maxX, minY, maxY };
				}

				_calculateDensity({ inkVolume, maxX, minX, maxY, minY }, metrics, fontSize) {
					const w = (maxX - minX + 1) || 1, h = (maxY - minY + 1) || 1;
					const emHeight = (metrics.font.ascender - metrics.font.descender) * (fontSize / metrics.font.unitsPerEm);
					const area = this.ui.densityMode.value === 'ink-box' ? w * h : metrics.advanceWidth * emHeight;
					return (inkVolume / area) * 100;
				}

				render() {
					const validAnalyses = this.analyses.filter(Boolean);
					if (!validAnalyses.length) {
						this.renderEmpty();
						this.updateResults();
						return;
					}
					const dims = this._calculateDimensions(validAnalyses);
					Object.assign(this.ui.canvas, dims);
					this.ctx.clearRect(0, 0, dims.width, dims.height);
					const isSideBySide = this.ui.renderMode.value === 'side-by-side' && validAnalyses.length > 1;
					let currentX = this.graphWidth + this.graphPadding;
					this.analyses.forEach((analysis, i) => {
						if (!analysis) return;
						const yOffset = dims.baseline - analysis.baseline - analysis.baselineShift;
						const blend = this.analyses[0] && this.analyses[1] && i > 0;
						this._drawDensityGraph(analysis, this.colors[i], yOffset, blend);
						this._drawText(analysis, this.colors[i], currentX, yOffset, blend);
						if (isSideBySide && this.analyses[i]) currentX += analysis.canvas.width;
					});
					this.requestScaling();
					this.updateResults();
				}

				renderEmpty() {
					Object.assign(this.ui.canvas, { width: 400, height: 200 });
					this.ctx.clearRect(0, 0, 400, 200);
					this.requestScaling();
				}

				_calculateDimensions(analyses) {
					const isSideBySide = this.ui.renderMode.value === 'side-by-side' && analyses.length > 1;
					const asc = Math.max(0, ...analyses.map(a => a.baseline - a.baselineShift));
					const desc = Math.max(0, ...analyses.map(a => (a.canvas.height - a.baseline) + a.baselineShift));
					const totalW = isSideBySide ? analyses.reduce((sum, a) => sum + a.canvas.width, 0) : Math.max(0, ...analyses.map(a => a.canvas.width));
					return {
						width: Math.ceil(this.graphWidth + this.graphPadding + totalW),
						height: Math.ceil(asc + desc),
						baseline: Math.ceil(asc),
					};
				}

				_drawText({ canvas: src }, color, x, y, blend) {
					const { tintContext: tctx, tintCanvas: tcvs, ctx } = this;
					Object.assign(tcvs, { width: src.width, height: src.height });
					tctx.clearRect(0, 0, tcvs.width, tcvs.height);
					tctx.fillStyle = color;
					tctx.fillRect(0, 0, tcvs.width, tcvs.height);
					tctx.globalCompositeOperation = 'destination-in';
					tctx.drawImage(src, 0, 0);
					ctx.globalCompositeOperation = blend ? 'multiply' : 'source-over';
					ctx.drawImage(tcvs, x, y);
					tctx.globalCompositeOperation = ctx.globalCompositeOperation = 'source-over';
				}

				_drawDensityGraph({ densityMap }, color, yOffset, blend) {
					const max = Math.max(1, ...densityMap);
					Object.assign(this.ctx, { fillStyle: color, globalCompositeOperation: blend ? 'multiply' : 'source-over' });
					densityMap.forEach((val, y) => {
						if (val > 0) this.ctx.fillRect(this.graphWidth - (val / max) * this.graphWidth, y + yOffset, (val / max) * this.graphWidth, 1);
					});
					this.ctx.globalCompositeOperation = 'source-over';
				}

				updateResults() {
					this.fontUIs.forEach((ui, i) => {
						ui.results.textContent = this._formatAnalysisResults(this.analyses[i], i);
					});
				}

				_formatAnalysisResults(analysis, index) {
					if (!analysis) return this.fonts[index] ? 'Enter text to analyze.' : 'Load a font to see analysis.';

					const formatVal = (key, unit = 'px') => `${key.replace(/([A-Z])/g, ' $1').replace(/^\w/, c => c.toUpperCase())}: ${Math.round(analysis[key])}${unit}`;

					const metrics = Object.keys(analysis)
						.filter(k => k.includes('Ascent') || k.includes('Descent'))
						.map(k => formatVal(k));

					const analysisData = {
						'Y Min': `${analysis.yMin}px`, 'Y Max': `${analysis.yMax}px`, 'Density': `${analysis.density}%`,
						'Font Size': `${analysis.fontSize}px`, 'Baseline Shift': `${analysis.baselineShift}px`, 'Letter Spacing': `${analysis.letterSpacing}px`
					};

					const analysisEntries = Object.entries(analysisData).map(([key, value]) => `${key}: ${value}`);

					return [...analysisEntries, ...metrics].join('\n');
				}

				updateDisplayScale() {
					const { style, parentElement, width, height } = this.ui.canvas;
					const wrapperStyle = parentElement.style;
					const isFitMode = this.ui.zoomMode.value === 'fit' && width > 0;

					style.transform = 'none';
					Object.assign(wrapperStyle, { width: '', height: '', overflow: '' });

					if (isFitMode) {
						const cs = getComputedStyle(parentElement);
						const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
						const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
						const scale = Math.min((parentElement.parentElement.clientWidth - padX) / width, 1);
						style.transform = `scale(${scale})`;
						Object.assign(wrapperStyle, {
							width: `${width * scale + padX}px`, height: `${height * scale + padY}px`, overflow: 'hidden'
						});
					}
				}
			}

			document.addEventListener('DOMContentLoaded', () => new DensityTool());
		</script>
	</body>
</html>
