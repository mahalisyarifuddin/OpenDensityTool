<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Typographic Density Tool</title>
		<style>
			:root {
				--primary: #005dac;
				--on-primary: #ffffff;
				--hover: #00539a;
				--background: #f9f9ff;
				--surface: #ffffff;
				--text: #181c21;
				--border: #c1c6d4;
				--muted: #f2f3fc;
				--success: #0b6b1d;
				--on-success: #ffffff;
				--danger: #ba1a1a;
				--on-danger: #ffffff;
				--highlight-bg: #d4e3ff;
			}
			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--primary: #a5c8ff;
					--on-primary: #00315f;
					--hover: #72adff;
					--background: #101319;
					--surface: #0b0e14;
					--text: #e0e2ea;
					--border: #414752;
					--muted: #181c21;
					--success: #82db7e;
					--on-success: #00390a;
					--danger: #ffb4ab;
					--on-danger: #93000a;
					--highlight-bg: #001c3a;
				}
			}
			:root.dark {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
			*:focus-visible {
				outline: 2px solid var(--primary);
				outline-offset: 2px;
			}
			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				line-height: 1.25;
				padding: 1.5rem;
				min-height: 100vh;
			}
			header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 2rem;
				max-width: 1600px;
				margin-left: auto;
				margin-right: auto;
			}
			h1 {
				margin: .5rem 0;
				font-size: 2rem;
				font-weight: 600;
			}
			main {
				display: grid;
				grid-template-columns: 330px 1fr;
				gap: 1.5rem;
				max-width: 1600px;
				margin: 0 auto;
			}
			section {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 1.5rem;
				min-width: 0;
			}
			h2 {
				margin: .5rem 0 1rem;
				border-bottom: 1px solid var(--border);
				padding-bottom: .75rem;
				font-size: 1.2rem;
				font-weight: 600;
			}
			.group {
				background: var(--background);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				margin-bottom: 1rem;
				position: relative;
			}
			.group.dragActive {
				border-color: var(--primary);
				background: var(--surface);
			}
			.group.dragActive::after {
				content: "Drop Font File";
				position: absolute;
				inset: 0;
				background: var(--surface);
				color: var(--primary);
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				font-weight: 700;
				border-radius: 6px;
				z-index: 10;
			}
			.header {
				display: flex;
				align-items: center;
				margin-bottom: .75rem;
				font-weight: 700;
			}
			.header span {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				min-width: 0;
			}
			input[type=color] {
				width: 24px;
				height: 24px;
				border: none;
				background: none;
				padding: 0;
				margin-right: .5em;
				cursor: pointer;
				flex-shrink: 0;
			}
			input[type=range] {
				width: 100%;
				margin-top: 6px;
				cursor: grab;
				accent-color: var(--primary);
			}
			input[type=range]:active {
				cursor: grabbing;
			}
			label {
				display: block;
				margin-bottom: .5rem;
				font-weight: 500;
				font-size: .9rem;
			}
			input:not([type=color]):not([type=range]), textarea, select, button {
				width: 100%;
				padding: .5rem .75rem;
				border: 1px solid var(--border);
				border-radius: 4px;
				background: var(--surface);
				color: var(--text);
				margin-top: 4px;
				font-family: inherit;
				font-size: .95rem;
			}
			textarea {
				resize: vertical;
				min-height: 80px;
				font-family: monospace;
				font-size: .8rem;
			}
			.row {
				display: flex;
				gap: 1rem;
			}
			.controls {
				display: flex;
				gap: .75rem;
				align-items: center;
				margin-bottom: 1rem;
			}
			.controlsSelection {
				display: flex;
				flex-wrap: wrap;
				gap: .75rem;
				flex: 1;
			}
			.controls select, button {
				width: auto;
				margin-top: 0;
				flex-shrink: 0;
			}
			button {
				background: var(--primary);
				color: var(--on-primary);
				border: 0;
				padding: .5rem 1rem;
				cursor: pointer;
			}
			button:hover {
				background: var(--hover);
			}
			dialog {
				background: var(--surface);
				color: var(--text);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 1.5rem;
				max-width: 400px;
				width: 100%;
				margin: auto;
				position: fixed;
			}
			dialog::backdrop {
				background: rgba(0, 0, 0, 0.5);
			}
			.dialog-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 1.5rem;
			}
			.dialog-header h3 {
				font-size: 1.25rem;
				font-weight: 600;
			}
			.close-button {
				background: transparent;
				color: var(--text);
				padding: .25rem;
				font-size: 1.5rem;
				line-height: 1;
			}
			.close-button:hover {
				background: var(--background);
				color: var(--text);
			}
			#preview {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto;
				margin-bottom: 1.5rem;
			}
			#container {
				padding: 1rem;
				display: flex;
				align-items: flex-start;
			}
			canvas {
				transform-origin: top left;
				display: block;
				flex-shrink: 0;
				background: var(--surface);
			}
			.results {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 1rem;
			}
			.card {
				background: var(--background);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				min-width: 0;
			}
			.output {
				font-family: monospace;
				font-size: .8rem;
				line-height: 1.5;
				margin-top: .5rem;
			}
			.statisticGrid {
				display: grid;
				gap: .5rem;
			}
			.statisticRow {
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.statisticGroup {
				margin-top: .5rem;
				border-top: 1px solid var(--border);
				padding-top: .5rem;
			}
			.statisticTitle {
				font-weight: 600;
				margin-bottom: .25rem;
				color: var(--text);
			}
			.statisticLabel {
				color: var(--text);
				opacity: .8;
			}
			.statisticValue {
				font-weight: 600;
			}
			.indicator {
				width: 14px;
				height: 14px;
				border-radius: 3px;
				display: inline-block;
				margin-right: .5em;
				flex-shrink: 0;
			}
			.actionButton {
				margin-left: auto;
				background: transparent;
				color: var(--primary);
				border: 1px solid transparent;
				padding: .25rem .5rem;
				font-size: .8rem;
				border-radius: 4px;
			}
			.actionButton:hover {
				background: var(--background);
				border-color: var(--muted);
				color: var(--hover);
			}
			.actionButton[aria-pressed="true"] {
				background: var(--primary);
				color: var(--on-primary);
			}
			.actionButton[aria-pressed="true"]:hover {
				background: var(--hover);
				color: var(--on-primary);
			}
			.spinner {
				width: 24px;
				height: 24px;
				border: 3px solid var(--border);
				border-top-color: var(--primary);
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin: 1rem auto;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			[hidden] {
				display: none !important;
			}
			@media (max-width: 900px) {
				main {
					grid-template-columns: 1fr;
				}
				.results {
					grid-template-columns: 1fr;
				}
			}
			.row label {
				display: flex;
				flex-direction: column;
				gap: 4px;
				flex: 1;
				min-width: 0;
			}
			.row label input:not([type=range]) {
				margin-top: auto;
			}
			#tooltip {
				position: fixed;
				background: rgba(0, 0, 0, 0.85);
				color: #fff;
				padding: 8px 12px;
				border-radius: 6px;
				font-size: 13px;
				pointer-events: none;
				z-index: 1000;
				white-space: pre;
				font-family: monospace;
				box-shadow: 0 4px 12px rgba(0,0,0,0.2);
			}
		</style>
	</head>
	<body>
		<div id="tooltip" hidden></div>
		<header>
			<h1>Typographic Density Tool</h1>
			<button id="openSettings" style="width:auto" aria-label="Open Settings">Settings</button>
		</header>
		<dialog id="preferencesDialog">
			<div class="dialog-header">
				<h3>Preferences</h3>
				<button id="closeSettings" class="close-button" aria-label="Close Settings">&times;</button>
			</div>
			<div class="group">
				<label>
					Theme
					<select id="theme" style="margin-top:4px">
						<option value="auto">Auto Theme</option>
						<option value="light">Light</option>
						<option value="dark">Dark</option>
					</select>
				</label>
				<label>
					Letter Spacing Unit
					<select id="spacingUnit" style="margin-top:4px">
						<option value="em" selected>Per mille (‰ em)</option>
						<option value="px">Pixels (px)</option>
						<option value="percent">Tracking (%)</option>
					</select>
				</label>
			</div>
		</dialog>
		<main>
			<section>
				<h2><div style="display:flex;justify-content:space-between;align-items:center">Configuration <button id="resetConfig" class="actionButton" style="width:auto;margin:0;font-weight:normal">Reset</button></div></h2>
				<div class="group">
					<div class="header">
						<input type="color" id="color1" value="#00a2a2" aria-label="Font 1 Color">
						<span id="name1">Font 1</span>
						<div class="controls" style="margin:0 0 0 auto;gap:4px">
							<button id="mute1" class="actionButton" aria-label="Toggle visibility Font 1" title="Toggle Visibility" aria-pressed="false">M</button>
							<button id="solo1" class="actionButton" aria-label="Solo Font 1" title="Solo" aria-pressed="false">S</button>
						</div>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file1" style="margin-bottom:0">Font File</label>
						<button id="clear1" class="actionButton" aria-label="Clear Font 1" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file1" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<div style="margin-bottom:.5rem">
						<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
							<label for="text1" style="margin-bottom:0">Text</label>
							<select id="samples1" class="actionButton" style="width:auto;padding:2px 6px;height:auto" aria-label="Text samples">
								<option value="">Samples...</option>
							</select>
						</div>
						<textarea id="text1" maxlength="1000">Idealogy</textarea>
					</div>
					<label>
						Size (px)<input type="number" id="size1" value="100" min="8" max="500">
						<input type="range" id="sizeRange1" value="100" min="6" max="500" aria-label="Size (px)">
					</label>
					<div class="row">
						<label>
							Letter Spacing (‰ em)<input type="number" id="spacing1" value="0" min="-500" max="500">
							<input type="range" id="spacingRange1" value="0" min="-500" max="500" aria-label="Letter Spacing (‰ em)">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift1" value="0" min="-200" max="200">
							<input type="range" id="shiftRange1" value="0" min="-200" max="200" aria-label="Baseline Shift">
						</label>
					</div>
				</div>
				<div class="group">
					<div class="header">
						<input type="color" id="color2" value="#ff00ff" aria-label="Font 2 Color">
						<span id="name2">Font 2</span>
						<div class="controls" style="margin:0 0 0 auto;gap:4px">
							<button id="mute2" class="actionButton" aria-label="Toggle visibility Font 2" title="Toggle Visibility" aria-pressed="false">M</button>
							<button id="solo2" class="actionButton" aria-label="Solo Font 2" title="Solo" aria-pressed="false">S</button>
						</div>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file2" style="margin-bottom:0">Font File</label>
						<button id="clear2" class="actionButton" aria-label="Clear Font 2" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file2" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<div style="margin-bottom:.5rem">
						<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
							<label for="text2" style="margin-bottom:0">Text</label>
							<select id="samples2" class="actionButton" style="width:auto;padding:2px 6px;height:auto" aria-label="Text samples">
								<option value="">Samples...</option>
							</select>
						</div>
						<textarea id="text2" maxlength="1000">Идеология</textarea>
					</div>
					<label>
						Size (px)<input type="number" id="size2" value="100" min="8" max="500">
						<input type="range" id="sizeRange2" value="100" min="6" max="500" aria-label="Size (px)">
					</label>
					<div class="row">
						<label>
							Letter Spacing (‰ em)<input type="number" id="spacing2" value="0" min="-500" max="500">
							<input type="range" id="spacingRange2" value="0" min="-500" max="500" aria-label="Letter Spacing (‰ em)">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift2" value="0" min="-200" max="200">
							<input type="range" id="shiftRange2" value="0" min="-200" max="200" aria-label="Baseline Shift">
						</label>
					</div>
				</div>
			</section>
			<section>
				<h2>Visualization</h2>
				<div class="controls">
					<div class="controlsSelection">
						<select id="zoom" aria-label="Zoom level">
							<option value="fit">Fit to View</option>
							<option value="100">100% Scale</option>
						</select>
						<select id="render" aria-label="Render mode">
							<option value="overlay">Overlay</option>
							<option value="side">Side-by-side</option>
						</select>
						<select id="density" aria-label="Density calculation method">
							<option value="ink">Ink Box</option>
							<option value="em">Em Box</option>
						</select>
						<select id="guides" aria-label="Guides">
							<option value="none">No Guides</option>
							<option value="baseline">Show Baseline</option>
							<option value="metrics">Show Metrics</option>
						</select>
					</div>
					<button id="copyImage">Copy Image</button>
					<button id="export">Export PNG</button>
				</div>
				<div id="preview">
					<div id="container">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results">
					<div class="card">
						<div class="header">
							<div id="dot1" class="indicator" aria-hidden="true"></div>
							<span id="analysisName1">Font 1 Analysis</span>
							<button class="actionButton copyButton" data-target="result1" aria-label="Copy Font 1 analysis">Copy</button>
						</div>
						<div id="result1" class="output" aria-live="polite"></div>
					</div>
					<div class="card">
						<div class="header">
							<div id="dot2" class="indicator" aria-hidden="true"></div>
							<span id="analysisName2">Font 2 Analysis</span>
							<button class="actionButton copyButton" data-target="result2" aria-label="Copy Font 2 analysis">Copy</button>
						</div>
						<div id="result2" class="output" aria-live="polite"></div>
					</div>
				</div>
			</section>
		</main>
		<script type="module">
			import * as fontkitModule from 'https://esm.sh/fontkit@2.0.4';
			import { Buffer } from 'https://esm.sh/buffer@6.0.3';

			const fontkit = fontkitModule.default || fontkitModule;
			window.Buffer = Buffer;
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
			const isLittleEndianArchitecture = new Uint8Array(new Uint32Array([1]).buffer)[0] === 1;
			const ALPHA_SHIFT = isLittleEndianArchitecture ? 31 : 7;
			const COMMON_SCRIPT_NAMES = new Set('General Punctuation|Superscripts and Subscripts|Currency Symbols|Combining Diacritical Marks for Symbols|Letterlike Symbols|Number Forms|Arrows|Mathematical Operators|Miscellaneous Technical|Control Pictures|Optical Character Recognition|Enclosed Alphanumerics|Box Drawing|Block Elements|Geometric Shapes|Miscellaneous Symbols|Dingbats|Miscellaneous Mathematical Symbols-A|Supplemental Arrows-A|Braille Patterns|Supplemental Arrows-B|Miscellaneous Mathematical Symbols-B|Supplemental Mathematical Operators|Miscellaneous Symbols and Arrows|Supplemental Punctuation|CJK Symbols and Punctuation|Halfwidth and Fullwidth Forms'.split('|'));
			const TEXT_SAMPLES = {
				"Pangram (En)": "The quick brown fox jumps over the lazy dog",
				"Pangram (Cy)": "Съешь же ещё этих мягких французских булок, да выпей чаю",
				"Alphabet": "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz",
				"Numbers": "0123456789",
				"Alignment": "Haxodp"
			};
			const row = (l, v) => `<div class="statisticRow"><span class="statisticLabel">${l}</span><span class="statisticValue">${v}</span></div>`;

			class DensityTool {
				constructor() {
					this.fonts = [];
					this.loadErrors = [];
					this.visibility = [true, true];
					this.solo = [false, false];
					this.loading = [false, false];
					this.loadSequence = [0, 0];
					this.renderingCache = [];
					this.layoutCache = [null, null];
					this.offscreenCanvases = [document.createElement('canvas'), document.createElement('canvas')];
					this.whiteCanvases = [document.createElement('canvas'), document.createElement('canvas')];
					this.compositeCanvas = document.createElement('canvas');
					this.graphWidth = 150;
					this.graphPadding = 20;
					this.context = elements.canvas.getContext('2d');
					this.unicodeBlocks = [];
					this.surfaceColor = '#ffffff';
					this.analyses = [];
					this.setup();
					this.theme('auto');
					this.update();
				}

				setup() {
					this.fetchUnicodeBlocks();

					const debounce = (callback, delay) => {
						let timer;
						return (...args) => {
							clearTimeout(timer);
							timer = setTimeout(() => callback(...args), delay);
						};
					};
					const debouncedUpdate = debounce(() => this.update(), 300);
					const throttledUpdate = () => {
						if (this.rafId) return;
						this.rafId = requestAnimationFrame(() => {
							this.update();
							this.rafId = null;
						});
					};
					const updateScale = () => {
						if (this.resizeRaf) cancelAnimationFrame(this.resizeRaf);
						this.resizeRaf = requestAnimationFrame(() => {
							this.updateScale();
							this.resizeRaf = null;
						});
					};

					const sampleOptions = Object.entries(TEXT_SAMPLES).map(([label, text]) => `<option value="${text}">${label}</option>`).join('');
					[1, 2].forEach(n => {
						const select = document.getElementById(`samples${n}`);
						if (select) {
							select.innerHTML += sampleOptions;
							select.onchange = () => {
								if (select.value) {
									elements[`text${n}`].value = select.value;
									select.value = "";
									debouncedUpdate();
								}
							};
						}
					});

					elements.zoom.onchange = updateScale;
					['render', 'density', 'guides'].forEach(id => {
						elements[id].onchange = () => this.update();
					});

					elements.export.onclick = () => {
						const originalText = elements.export.textContent;
						elements.export.textContent = 'Exporting...';
						setTimeout(() => {
							const link = document.createElement('a');
							link.href = elements.canvas.toDataURL();
							const names = this.fonts.map((f, i) => f ? f.fullName.replace(/[^a-z0-9]/gi, '') : '').filter(Boolean);
							const namePart = names.length ? names.join('_vs_') : new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
							link.download = `density_${namePart}.png`;
							link.click();
							elements.export.textContent = 'Saved!';
							setTimeout(() => elements.export.textContent = originalText, 2000);
						}, 50);
					};

					elements.copyImage.onclick = () => {
						const originalText = elements.copyImage.textContent;
						elements.copyImage.textContent = 'Copying...';
						elements.canvas.toBlob(blob => {
							if (!blob) {
								elements.copyImage.textContent = 'Error';
								setTimeout(() => elements.copyImage.textContent = originalText, 2000);
								return;
							}
							try {
								const item = new ClipboardItem({ "image/png": blob });
								navigator.clipboard.write([item])
									.then(() => elements.copyImage.textContent = 'Copied!')
									.catch(err => {
										console.error(err);
										elements.copyImage.textContent = 'Error';
									})
									.finally(() => setTimeout(() => elements.copyImage.textContent = originalText, 2000));
							} catch (err) {
								console.error(err);
								elements.copyImage.textContent = 'Error';
								setTimeout(() => elements.copyImage.textContent = originalText, 2000);
							}
						});
					};

					elements.theme.onchange = event => this.theme(event.target.value);

					window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
						this.updateThemeColor();
						elements.theme.value === 'auto' && this.draw();
					});

					elements.openSettings.onclick = () => elements.preferencesDialog.showModal();
					elements.closeSettings.onclick = () => elements.preferencesDialog.close();
					elements.spacingUnit.onchange = () => {
						this.updateSpacingLabels();
						this.update();
					};

					elements.resetConfig.onclick = () => {
						[1, 2].forEach(n => {
							['text', 'size', 'spacing', 'shift', 'color'].forEach(key => {
								const el = elements[`${key}${n}`];
								el.value = el.defaultValue;
								if (key !== 'text' && key !== 'color') elements[`${key}Range${n}`].value = el.value;
							});
						});
						this.update();
					};

					window.onresize = updateScale;

					document.querySelectorAll('.copyButton').forEach(button => {
						const originalText = button.textContent;
						button.onclick = () => {
							const text = document.getElementById(button.dataset.target).innerText;
							navigator.clipboard.writeText(text)
								.then(() => button.textContent = 'Copied!')
								.catch(() => button.textContent = 'Error')
								.finally(() => setTimeout(() => button.textContent = originalText, 2000));
						};
					});

					[1, 2].forEach((number, index) => {
						const fileInput = elements[`file${number}`];
						const group = fileInput.closest('.group');

						fileInput.onchange = event => this.loadFont(event.target.files[0], index);

						elements[`clear${number}`].onclick = () => {
							this.fonts[index] = null;
							this.loadErrors[index] = null;
							fileInput.value = '';
							this.update();
						};

						elements[`text${number}`].oninput = debouncedUpdate;
						elements[`color${number}`].oninput = throttledUpdate;

						const bindInput = (key, updateFn) => {
							const numInput = elements[`${key}${number}`];
							const rangeInput = elements[`${key}Range${number}`];
							numInput.oninput = () => { rangeInput.value = numInput.value; updateFn(); };
							rangeInput.oninput = () => { numInput.value = rangeInput.value; updateFn(); };
						};

						bindInput('size', debouncedUpdate);
						bindInput('spacing', debouncedUpdate);
						bindInput('shift', throttledUpdate);

						group.ondragover = event => {
							event.preventDefault();
							group.classList.add('dragActive');
						};

						group.ondragleave = event => {
							if (!event.relatedTarget || !group.contains(event.relatedTarget)) {
								group.classList.remove('dragActive');
							}
						};

						group.ondrop = event => {
							event.preventDefault();
							group.classList.remove('dragActive');
							const droppedFile = event.dataTransfer.files[0];
							if (droppedFile) {
								fileInput.files = event.dataTransfer.files;
								this.loadFont(droppedFile, index);
							}
						};

						elements[`mute${number}`].onclick = () => {
							this.visibility[index] = !this.visibility[index];
							elements[`mute${number}`].setAttribute('aria-pressed', !this.visibility[index]);
							this.draw();
						};
						elements[`solo${number}`].onclick = () => {
							this.solo[index] = !this.solo[index];
							elements[`solo${number}`].setAttribute('aria-pressed', this.solo[index]);
							this.draw();
						};
					});

					elements.canvas.onmousemove = e => {
						const { clientX, clientY } = e;
						if (this.tooltipRaf) cancelAnimationFrame(this.tooltipRaf);
						this.tooltipRaf = requestAnimationFrame(() => {
							if (!this.lastDimensions) return;
							const rect = elements.canvas.getBoundingClientRect();
							const x = (clientX - rect.left) * (elements.canvas.width / rect.width);
							const y = (clientY - rect.top) * (elements.canvas.height / rect.height);
							if (x > this.graphWidth || x < 0) return elements.tooltip.hidden = true;

							const content = this.analyses.map((a, i) => {
								if (!a || a.error || !this.isFontVisible(i)) return null;
								const rowY = Math.floor(y - (this.lastDimensions.baseline - a.baseline - a.baselineShift));
								const val = (rowY >= 0 && rowY < a.densityByRow.length) ? a.densityByRow[rowY] : 0;
								const name = this.fonts[i]?.fullName || `Font ${i + 1}`;
								const percentage = Math.round((val / a.maxDensity) * 100);
								return val ? `${name}: ${val}px (${percentage}%)` : null;
							}).filter(Boolean).join('\n');

							if (!content) return elements.tooltip.hidden = true;

							elements.tooltip.innerText = `Y: ${Math.round(this.lastDimensions.baseline - y)}\n${content}`;
							elements.tooltip.hidden = false;
							elements.tooltip.style.left = `${clientX + 15}px`;
							elements.tooltip.style.top = `${clientY + 15}px`;
							this.tooltipRaf = null;
						});
					};
					elements.canvas.onmouseleave = () => elements.tooltip.hidden = true;
				}

				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
					this.updateThemeColor();
					this.draw();
				}

				parseColor(color) {
					if (!color) return { r: 0, g: 0, b: 0, a: 0 };
					if (color.startsWith('#')) {
						const hex = color.length === 4 ? color.slice(1).split('').map(c => c + c).join('') : color.slice(1);
						const r = parseInt(hex.slice(0, 2), 16);
						const g = parseInt(hex.slice(2, 4), 16);
						const b = parseInt(hex.slice(4, 6), 16);
						return { r, g, b, a: 1 };
					}
					const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
					if (match) {
						return {
							r: parseInt(match[1], 10),
							g: parseInt(match[2], 10),
							b: parseInt(match[3], 10),
							a: match[4] !== undefined ? parseFloat(match[4]) : 1
						};
					}
					return { r: 0, g: 0, b: 0, a: 0 };
				}

				updateThemeColor() {
					this.themeSurfaceColor = getComputedStyle(document.documentElement).getPropertyValue('--surface').trim() || '#ffffff';
					this.canvasBackgroundColor = getComputedStyle(elements.canvas).backgroundColor;
				}

				fetchUnicodeBlocks() {
					fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://www.unicode.org/Public/latest/ucd/Blocks.txt'))
						.then(response => { if (!response.ok) throw new Error(); return response.text(); })
						.then(text => {
							const ranges = [];
							for (const match of text.matchAll(/^([0-9A-F]+)\.\.([0-9A-F]+);\s*(.+)$/gm)) {
								ranges.push([parseInt(match[1], 16), parseInt(match[2], 16), match[3]]);
							}
							ranges.length > 0 && (this.unicodeBlocks = ranges, this.layoutCache = [null, null], this.lastBlock = null, this.update());
						})
						.catch(error => console.warn('Block fetch failed', error));
				}

				async loadFont(file, index) {
					const currentSequence = ++this.loadSequence[index];
					this.loadErrors[index] = this.fonts[index] = null;
					this.loading[index] = true;
					this.update();
					try {
						if (!file) return;
						if (file.size > 30 * 1024 * 1024) throw new Error('File too large (max 30MB)');
						const buffer = await file.arrayBuffer();
						if (currentSequence === this.loadSequence[index]) {
							const font = fontkit.create(window.Buffer.from(buffer));
							if (!font.unitsPerEm) throw new Error('Invalid font');
							this.fonts[index] = font;
						}
					} catch (error) {
						currentSequence === this.loadSequence[index] && (this.loadErrors[index] = error.message);
					} finally {
						currentSequence === this.loadSequence[index] && (this.loading[index] = false, this.update());
					}
				}

				getRenderData(index) {
					const number = index + 1;
					const inputs = { font: this.fonts[index], content: elements[`text${number}`].value, fontSize: +elements[`size${number}`].value || 0, letterSpacing: +elements[`spacing${number}`].value || 0, color: elements[`color${number}`].value };
					if (!inputs.font || !inputs.fontSize) return null;
					const cached = this.renderingCache[index];
					if (cached) {
						const keys = Object.keys(inputs);
						if (keys.every(key => cached.inputs[key] === inputs[key])) return cached.data;
						if (keys.every(key => key === 'color' || cached.inputs[key] === inputs[key]) && cached.data) {
							const context = cached.data.canvas.getContext('2d');
							context.save();
							context.globalCompositeOperation = 'source-in';
							context.fillStyle = inputs.color;
							context.fillRect(0, 0, cached.data.width, cached.data.height);
							context.restore();
							cached.inputs.color = inputs.color;
							return cached.data;
						}
					}
					return this.generateRenderData(index, inputs);
				}

				getScript(char) {
					const code = char.codePointAt(0);
					if (!this.lastBlock || code < this.lastBlock[0] || code > this.lastBlock[1]) {
						this.lastBlock = this.unicodeBlocks.find(b => code >= b[0] && code <= b[1]);
					}
					return this.lastBlock ? this.getScriptName(code, this.lastBlock) : 'Other';
				}

				getScriptName(code, block) {
					const name = block[2];
					if (name === "Basic Latin") return (code <= 0x40 || (code >= 0x5B && code <= 0x60) || code >= 0x7B) ? 'Common' : 'Latin';
					return name.includes("Latin") ? 'Latin' : COMMON_SCRIPT_NAMES.has(name) ? 'Common' : name;
				}

				generateRenderData(index, inputs) {
					const { font, content, fontSize, letterSpacing, color } = inputs;
					const size = Math.min(Math.max(fontSize, 1), 2000);
					const scale = size / font.unitsPerEm;
					const unit = elements.spacingUnit.value;

					const tracking = unit === 'percent' ? 0 :
									 unit === 'em' ? (letterSpacing / 1000) * font.unitsPerEm :
									 (letterSpacing ? (letterSpacing / size) * font.unitsPerEm : 0);

					const advanceScale = unit === 'percent' ? (letterSpacing / 100) : 1;

					const cachedLayout = this.layoutCache[index];
					const hit = cachedLayout && cachedLayout.content === content && cachedLayout.font === font;
					const runs = hit ? cachedLayout.runs : (() => {
						const segments = [];
						let currentSegment = { text: '', script: null };
						for (const char of content) {
							const script = this.getScript(char);
							if (!currentSegment.script) { currentSegment = { text: char, script: script === 'Common' ? 'Other' : script }; continue; }
							if (script === 'Common' || script === currentSegment.script) { currentSegment.text += char; continue; }
							segments.push(currentSegment);
							currentSegment = { text: char, script };
						}
						currentSegment.text && segments.push(currentSegment);
						const result = segments.map(segment => ({ run: font.layout(segment.text), text: segment.text }));
						this.layoutCache[index] = { content, font, runs: result };
						return result;
					})();

					let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, currentX = 0;
					runs.forEach(({ run }) => {
						run.glyphs.forEach((glyph, i) => {
							const position = run.positions[i];
							const boundingBox = glyph.bbox;
							if (boundingBox) {
								const x = currentX + position.xOffset;
								const y = position.yOffset;
								minX = Math.min(minX, x + boundingBox.minX);
								maxX = Math.max(maxX, x + boundingBox.maxX);
								minY = Math.min(minY, y + boundingBox.minY);
								maxY = Math.max(maxY, y + boundingBox.maxY);
							}
							currentX += (position.xAdvance * advanceScale) + tracking;
						});
					});
					if (minX === Infinity) minX = maxX = minY = maxY = 0;
					const metrics = { ascent: Math.max(maxY * scale, (font.ascent || 0) * scale), descent: Math.max(-minY * scale, Math.abs(font.descent || 0) * scale), fontAscent: (font.ascent || 0) * scale, fontDescent: Math.abs(font.descent || 0) * scale, fontCapHeight: (font.capHeight || 0) * scale, fontXHeight: (font.xHeight || 0) * scale, advanceWidth: Math.ceil(currentX * scale) };
					const safetyPadding = 0;
					const minXPixel = Math.min(0, minX * scale);
					const maxXPixel = Math.max(metrics.advanceWidth, maxX * scale);
					const drawOffsetX = -minXPixel + safetyPadding;
					const width = Math.ceil(maxXPixel - minXPixel) + (safetyPadding * 2);
					const baseline = Math.ceil(metrics.ascent) + safetyPadding;
					const height = Math.ceil(baseline + metrics.descent + safetyPadding);
					if (width > 32767 || height > 32767) throw new Error('Canvas dimensions too large');
					const whiteCanvas = this.whiteCanvases[index];
					whiteCanvas.width = Math.max(whiteCanvas.width, width);
					whiteCanvas.height = Math.max(whiteCanvas.height, height);
					const whiteContext = whiteCanvas.getContext('2d', { willReadFrequently: true });
					whiteContext.clearRect(0, 0, width, height);
					whiteContext.save();
					whiteContext.translate(drawOffsetX, baseline);
					whiteContext.scale(1, -1);
					whiteContext.fillStyle = '#FFFFFF';
					let drawX = 0;
					runs.forEach(({ run }) => {
						run.glyphs.forEach((glyph, i) => {
							const position = run.positions[i];
							whiteContext.save();
							whiteContext.translate((drawX + position.xOffset) * scale, position.yOffset * scale);
							whiteContext.beginPath();
							glyph.render(whiteContext, size);
							whiteContext.restore();
							drawX += (position.xAdvance * advanceScale) + tracking;
						});
					});
					whiteContext.restore();

					const canvas = this.offscreenCanvases[index];
					canvas.width = Math.max(canvas.width, width);
					canvas.height = Math.max(canvas.height, height);
					const context = canvas.getContext('2d', { willReadFrequently: true });
					context.clearRect(0, 0, width, height);
					context.drawImage(whiteCanvas, 0, 0);
					context.globalCompositeOperation = 'source-in';
					context.fillStyle = color;
					context.fillRect(0, 0, width, height);
					context.globalCompositeOperation = 'source-over';

					const analysisData = this.analyzePixels(context, width, height);

					const graphPath = new Path2D();
					const graphScale = this.graphWidth / analysisData.maxDensity;
					let currentGraphWidth = 0, startGraphY = -1;
					for (let rowY = 0; rowY < analysisData.densityByRow.length; rowY++) {
						const barWidth = analysisData.densityByRow[rowY] ? analysisData.densityByRow[rowY] * graphScale : 0;
						if (barWidth !== currentGraphWidth) {
							if (currentGraphWidth > 0) graphPath.rect(this.graphWidth - currentGraphWidth, startGraphY, currentGraphWidth, rowY - startGraphY);
							currentGraphWidth = barWidth; startGraphY = rowY;
						}
					}
					if (currentGraphWidth > 0) graphPath.rect(this.graphWidth - currentGraphWidth, startGraphY, currentGraphWidth, analysisData.densityByRow.length - startGraphY);

					const data = { ...analysisData, graphPath, ...metrics, drawOffsetX, width, height, canvas, whiteCanvas, baseline, letterSpacing, fontSize: size, font };
					this.renderingCache[index] = { inputs, data };
					return data;
				}

				analyzePixels(context, width, height) {
					if (width === 0 || height === 0) return { densityByRow: new Float32Array(height), inkPixels: 0, minX: 0, maxX: 0, minY: 0, maxY: 0, maxDensity: 1 };
					const { data } = context.getImageData(0, 0, width, height);
					const pixelDataInt32 = new Uint32Array(data.buffer);
					const densityByRow = new Float32Array(height);
					let inkPixels = 0, minX = width, maxX = -1, minY = height, maxY = -1;
					let maxDensity = 0;

					for (let y = 0; y < height; y++) {
						const rowStart = y * width;
						const rowEnd = rowStart + width;
						let index = rowStart;

						// Optimization: Scan for start
						while (index < rowEnd && !((pixelDataInt32[index] >>> ALPHA_SHIFT) & 1)) {
							index++;
						}
						if (index === rowEnd) continue;
						const firstX = index - rowStart;

						// Optimization: Scan for end
						let endIndex = rowEnd - 1;
						while (endIndex > index && !((pixelDataInt32[endIndex] >>> ALPHA_SHIFT) & 1)) {
							endIndex--;
						}
						const lastX = endIndex - rowStart;

						// Optimization: Count middle
						let rowInk = 0;
						for (; index <= endIndex; index++) {
							// Branchless optimization
							rowInk += (pixelDataInt32[index] >>> ALPHA_SHIFT) & 1;
						}

						densityByRow[y] = rowInk;
						if (rowInk > maxDensity) maxDensity = rowInk;
						inkPixels += rowInk;
						if (minX > firstX) minX = firstX;
						if (maxX < lastX) maxX = lastX;
						if (minY > y) minY = y;
						maxY = y;
					}
					return { densityByRow, inkPixels, minX, maxX, minY, maxY, maxDensity: Math.max(1, maxDensity) };
				}

				updateSpacingLabels() {
					const unit = elements.spacingUnit.value;
					const label = unit === 'percent' ? 'Tracking (%)' : unit === 'em' ? 'Letter Spacing (‰ em)' : 'Letter Spacing (px)';
					const defaultVal = unit === 'percent' ? 100 : 0;
					[1, 2].forEach(n => {
						const input = elements[`spacing${n}`];
						const range = elements[`spacingRange${n}`];
						const prevLabel = input.parentElement.firstChild;
						prevLabel.textContent = label;
						range.setAttribute('aria-label', label);
						input.value = defaultVal;
						range.value = defaultVal;
					});
				}

				isFontVisible(index) {
					return this.solo.some(s => s) ? this.solo[index] : this.visibility[index];
				}

				update() {
					this.analyses = [1, 2].map((number, index) => {
						elements[`dot${number}`].style.backgroundColor = elements[`color${number}`].value;
						try {
							const data = this.getRenderData(index);
							if (!data) return null;
							const hasInk = data.maxY >= data.minY;
							const area = Math.max(1, elements.density.value === 'ink' ? (hasInk ? (data.maxX - data.minX + 1) * (data.maxY - data.minY + 1) : 1) : Math.max(1, data.advanceWidth) * (data.ascent + data.descent));
							const yMin = hasInk ? Math.round(data.baseline - data.maxY) : 0;
							const yMax = hasInk ? Math.round(data.baseline - data.minY) : 0;
							return { ...data, baselineShift: +elements[`shift${number}`].value || 0, density: ((data.inkPixels / area) * 100).toFixed(1), yMin, yMax, inkHeight: hasInk ? (data.maxY - data.minY + 1) : 0 };
						} catch (error) { return { error: error.message }; }
					});
					this.draw();
					[1, 2].forEach((number, index) => this.updateResult(number, index));
				}

				draw() {
					const validAnalyses = this.analyses.filter((analysis, index) => analysis && !analysis.error && this.isFontVisible(index));
					if (!validAnalyses.length) { this.context.canvas.height = 150; this.updateScale(); return; }
					const sideMode = elements.render.value === 'side' && validAnalyses.length > 1;
					const max = callback => Math.max(0, ...validAnalyses.map(callback));
					const maxAscent = max(item => item.baseline + item.baselineShift);
					const maxDescent = max(item => item.height - item.baseline - item.baselineShift);
					const maxOffsetX = max(item => item.drawOffsetX);
					const totalWidth = sideMode ? validAnalyses.reduce((total, item) => total + item.width, 0) : maxOffsetX + max(item => item.width - item.drawOffsetX);
					const dimensions = { width: Math.ceil(this.graphWidth + this.graphPadding + totalWidth), height: Math.ceil(maxAscent + maxDescent), baseline: Math.ceil(maxAscent), maxDrawOffsetX: maxOffsetX };
					this.lastDimensions = dimensions;
					this.context.canvas.width = dimensions.width;
					this.context.canvas.height = dimensions.height;

					const themeColor = this.parseColor(this.themeSurfaceColor);
					const canvasColor = this.parseColor(this.canvasBackgroundColor);

					this.context.fillStyle = this.canvasBackgroundColor;
					this.context.fillRect(0, 0, dimensions.width, dimensions.height);

					// Determine theme brightness using effective color
					const alpha = canvasColor.a;
					const effectiveR = canvasColor.r * alpha + themeColor.r * (1 - alpha);
					const effectiveG = canvasColor.g * alpha + themeColor.g * (1 - alpha);
					const effectiveB = canvasColor.b * alpha + themeColor.b * (1 - alpha);

					const isDark = (effectiveR * 0.299 + effectiveG * 0.587 + effectiveB * 0.114) < 128;

					const compositeCanvas = this.compositeCanvas;
					compositeCanvas.width = dimensions.width;
					compositeCanvas.height = dimensions.height;
					const compositeCtx = compositeCanvas.getContext('2d');

					if (isDark) {
						if (!this.maskCanvas) {
							this.maskCanvas = document.createElement('canvas');
							this.invInkCanvas = document.createElement('canvas');
							this.emissiveInkCanvas = document.createElement('canvas');
							this.invMaskCanvas = document.createElement('canvas');
							this.diffCanvas = document.createElement('canvas');
							this.lightCanvas = document.createElement('canvas');
							this.tempCanvas = document.createElement('canvas');
						}
						[this.maskCanvas, this.invInkCanvas, this.emissiveInkCanvas, this.invMaskCanvas, this.diffCanvas, this.lightCanvas].forEach(c => {
							if (c.width !== dimensions.width || c.height !== dimensions.height) {
								c.width = dimensions.width;
								c.height = dimensions.height;
							}
						});

						const maskCtx = this.maskCanvas.getContext('2d');
						const invInkCtx = this.invInkCanvas.getContext('2d');
						const emissiveCtx = this.emissiveInkCanvas.getContext('2d');
						const invMaskCtx = this.invMaskCanvas.getContext('2d');
						const diffCtx = this.diffCanvas.getContext('2d');
						const lightCtx = this.lightCanvas.getContext('2d');
						const tempCtx = this.tempCanvas.getContext('2d');

						// Clear canvases
						maskCtx.globalCompositeOperation = 'source-over';
						maskCtx.fillStyle = '#000000';
						maskCtx.fillRect(0, 0, dimensions.width, dimensions.height);

						invInkCtx.globalCompositeOperation = 'source-over';
						invInkCtx.fillStyle = '#000000';
						invInkCtx.fillRect(0, 0, dimensions.width, dimensions.height);

						lightCtx.clearRect(0, 0, dimensions.width, dimensions.height);

						let currentTranslateX = this.graphWidth + this.graphPadding + (sideMode ? 0 : dimensions.maxDrawOffsetX);
						this.analyses.forEach((analysis, index) => {
							if (!analysis || analysis.error || !this.isFontVisible(index)) return;
							const y = dimensions.baseline - analysis.baseline - analysis.baselineShift;
							const colorHex = elements[`color${index + 1}`].value;
							const r = parseInt(colorHex.slice(1, 3), 16);
							const g = parseInt(colorHex.slice(3, 5), 16);
							const b = parseInt(colorHex.slice(5, 7), 16);

							const minVal = Math.min(r, g, b);
							const inkAlpha = (255 - minVal) / 255;
							const lightAlpha = minVal / 255;

							const draw = (ctx, imageSource) => {
								ctx.save();
								ctx.translate(0, y);
								ctx.fill(analysis.graphPath);
								ctx.restore();

								const drawX = sideMode ? currentTranslateX + (analysis.drawOffsetX || 0) : currentTranslateX;
								ctx.drawImage(imageSource, 0, 0, analysis.width, analysis.height, drawX - (analysis.drawOffsetX || 0), y, analysis.width, analysis.height);
							};

							const prepareTint = (fillStyle, sourceCanvas) => {
								if (this.tempCanvas.width < analysis.width || this.tempCanvas.height < analysis.height) {
									this.tempCanvas.width = Math.max(this.tempCanvas.width, analysis.width);
									this.tempCanvas.height = Math.max(this.tempCanvas.height, analysis.height);
								}
								tempCtx.clearRect(0, 0, analysis.width, analysis.height);
								tempCtx.globalCompositeOperation = 'source-over';
								tempCtx.drawImage(sourceCanvas || analysis.canvas, 0, 0);
								tempCtx.globalCompositeOperation = 'source-in';
								tempCtx.fillStyle = fillStyle;
								tempCtx.fillRect(0, 0, analysis.width, analysis.height);
								return this.tempCanvas;
							};

							if (inkAlpha > 0) {
								// Accumulate Alpha on Mask (Lighter)
								// Optimized: Use cached whiteCanvas directly to avoid tinting step
								const whiteImg = analysis.whiteCanvas || prepareTint('#ffffff');
								maskCtx.save();
								maskCtx.globalCompositeOperation = 'lighter';
								maskCtx.globalAlpha = inkAlpha;
								maskCtx.fillStyle = '#ffffff';
								draw(maskCtx, whiteImg);
								maskCtx.restore();

								// Accumulate InvColor on InvInk (Screen)
								const invColor = `rgb(${255 - r},${255 - g},${255 - b})`;
								// Optimized: Use whiteCanvas as source for tinting to avoid clearing color first
								const invImg = prepareTint(invColor, analysis.whiteCanvas);
								invInkCtx.save();
								invInkCtx.globalCompositeOperation = 'screen';
								invInkCtx.globalAlpha = inkAlpha;
								invInkCtx.fillStyle = invColor;
								draw(invInkCtx, invImg);
								invInkCtx.restore();
							}

							if (lightAlpha > 0) {
								lightCtx.save();
								lightCtx.globalCompositeOperation = 'screen';
								lightCtx.globalAlpha = lightAlpha;
								lightCtx.fillStyle = colorHex;
								draw(lightCtx, analysis.canvas);
								lightCtx.restore();
							}

							if (sideMode) currentTranslateX += analysis.width;
						});

						// Create Emissive Ink (Difference)
						// Result = Mask - InvInk = C * alpha (premultiplied)
						// Use diffCanvas to perform difference, then lighter to recover opacity
						diffCtx.globalCompositeOperation = 'source-over';
						diffCtx.fillStyle = '#000000';
						diffCtx.fillRect(0, 0, dimensions.width, dimensions.height);
						diffCtx.drawImage(this.maskCanvas, 0, 0);
						diffCtx.globalCompositeOperation = 'difference';
						diffCtx.drawImage(this.invInkCanvas, 0, 0);

						emissiveCtx.globalCompositeOperation = 'source-over';
						emissiveCtx.fillStyle = '#000000';
						emissiveCtx.fillRect(0, 0, dimensions.width, dimensions.height);
						emissiveCtx.globalCompositeOperation = 'lighter';
						emissiveCtx.drawImage(this.diffCanvas, 0, 0);

						// Create Inverse Mask
						// Result = White - Mask = 1 - alpha
						diffCtx.globalCompositeOperation = 'source-over';
						diffCtx.fillStyle = '#ffffff';
						diffCtx.fillRect(0, 0, dimensions.width, dimensions.height);
						diffCtx.globalCompositeOperation = 'difference';
						diffCtx.drawImage(this.maskCanvas, 0, 0);

						invMaskCtx.globalCompositeOperation = 'source-over';
						invMaskCtx.fillStyle = '#000000';
						invMaskCtx.fillRect(0, 0, dimensions.width, dimensions.height);
						invMaskCtx.globalCompositeOperation = 'lighter';
						invMaskCtx.drawImage(this.diffCanvas, 0, 0);

						// Composite onto Main Context
						// 1. Carve out background: Bg * (1 - alpha)
						this.context.save();
						this.context.globalCompositeOperation = 'multiply';
						this.context.drawImage(this.invMaskCanvas, 0, 0);
						this.context.restore();

						// 2. Add Emissive Ink: + C * alpha
						this.context.save();
						this.context.globalCompositeOperation = 'lighter';
						this.context.drawImage(this.emissiveInkCanvas, 0, 0);
						this.context.restore();

						// 3. Add Lights
						this.context.save();
						this.context.globalCompositeOperation = 'screen';
						this.context.drawImage(this.lightCanvas, 0, 0);
						this.context.restore();

					} else {
						// Light Mode (Standard Multiply)
						let currentTranslateX = this.graphWidth + this.graphPadding + (sideMode ? 0 : dimensions.maxDrawOffsetX);
						this.analyses.forEach((analysis, index) => {
							if (!analysis || analysis.error || !this.isFontVisible(index)) return;
							const y = dimensions.baseline - analysis.baseline - analysis.baselineShift;
							const colorHex = elements[`color${index + 1}`].value;
							const r = parseInt(colorHex.slice(1, 3), 16);
							const g = parseInt(colorHex.slice(3, 5), 16);
							const b = parseInt(colorHex.slice(5, 7), 16);
							const densityAlpha = (255 - Math.min(r, g, b)) / 255;

							compositeCtx.save();
							compositeCtx.globalAlpha = densityAlpha;
							compositeCtx.globalCompositeOperation = 'multiply';

							// Draw density graph
							compositeCtx.fillStyle = colorHex;
							compositeCtx.save();
							compositeCtx.translate(0, y);
							compositeCtx.fill(analysis.graphPath);
							compositeCtx.restore();

							// Draw glyphs
							const drawX = sideMode ? currentTranslateX + (analysis.drawOffsetX || 0) : currentTranslateX;
							compositeCtx.drawImage(analysis.canvas, 0, 0, analysis.width, analysis.height, drawX - (analysis.drawOffsetX || 0), y, analysis.width, analysis.height);
							compositeCtx.restore();

							if (sideMode) currentTranslateX += analysis.width;
						});
						this.context.drawImage(compositeCanvas, 0, 0);
					}
					const guides = elements.guides.value;
					if (['baseline', 'metrics'].includes(guides)) {
						this.context.fillStyle = 'rgba(255, 0, 0, 0.5)';
						this.context.fillRect(0, dimensions.baseline, this.context.canvas.width, 1);
					}
					if (guides === 'metrics') {
						validAnalyses.forEach((analysis, index) => {
							const y = dimensions.baseline - analysis.baselineShift;
							this.context.fillStyle = elements[`color${index + 1}`].value;
							this.context.globalAlpha = 0.5;
							this.context.fillRect(0, Math.floor(y - analysis.fontAscent), this.context.canvas.width, 1);
							this.context.fillRect(0, Math.floor(y + analysis.fontDescent), this.context.canvas.width, 1);
							this.context.globalAlpha = 0.3;
							this.context.fillRect(0, Math.floor(y - analysis.fontCapHeight), this.context.canvas.width, 1);
							this.context.fillRect(0, Math.floor(y - analysis.fontXHeight), this.context.canvas.width, 1);
							this.context.globalAlpha = 1.0;
						});
					}
					this.updateScale();
				}

				updateScale() {
					const { canvas, container, preview } = elements;
					canvas.style.transform = 'none';
					container.style.width = container.style.height = container.style.overflow = '';
					if (elements.zoom.value !== 'fit' || !canvas.width) return;
					const style = getComputedStyle(container);
					const scale = Math.min((preview.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight)) / canvas.width, 1);
					canvas.style.transform = `scale(${scale})`;
					container.style.width = `${canvas.width * scale + parseFloat(style.paddingLeft) + parseFloat(style.paddingRight)}px`;
					container.style.height = `${canvas.height * scale + parseFloat(style.paddingTop) + parseFloat(style.paddingBottom)}px`;
					container.style.overflow = 'hidden';
				}

				updateResult(number, index) {
					const analysis = this.analyses[index];
					const error = this.loadErrors[index] || (analysis && analysis.error);
					const message = error ? `Error: ${error}` : !this.fonts[index] ? 'Load font.' : !analysis ? 'Invalid settings.' : '';
					const name = this.fonts[index] ? (this.fonts[index].fullName || `Font ${number}`) : `Font ${number}`;
					elements[`name${number}`].textContent = elements[`name${number}`].title = name;
					elements[`analysisName${number}`].textContent = elements[`analysisName${number}`].title = `${name} Analysis`;
					elements[`color${number}`].setAttribute('aria-label', `${name} Color`);
					elements[`analysisName${number}`].nextElementSibling.setAttribute('aria-label', `Copy ${name} analysis`);

					if (this.loading[index]) {
						elements[`result${number}`].innerHTML = '<div class="spinner" aria-label="Loading"></div>';
						return;
					}
					if (message) {
						elements[`result${number}`].innerHTML = `<div class="state-message">${message}</div>`;
						return;
					}

					elements[`result${number}`].innerHTML = `<div class="statisticGrid">${row('Density', analysis.density + '%')}<div class="statisticGroup"><div class="statisticTitle">Ink Bounds</div>${row('Max Y', analysis.yMax)}${row('Min Y', analysis.yMin)}${row('Height', analysis.inkHeight)}</div><div class="statisticGroup"><div class="statisticTitle">Metrics</div>${row('Ascent', Math.round(analysis.fontAscent))}${row('Cap Height', Math.round(analysis.fontCapHeight))}${row('x-Height', Math.round(analysis.fontXHeight))}${row('Descent', '-' + Math.round(analysis.fontDescent))}</div></div>`;
				}
			}
			new DensityTool();
		</script>
	</body>
</html>
