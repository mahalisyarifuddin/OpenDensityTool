<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typographic Density Tool</title>
    <script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
    <style>
        :root {
            --primary: #0070ea;
            --background: #f7f7f8;
            --surface: #fff;
            --text: #333;
            --border: #e0e0e0;
            --input: #fff;
        }
        @media (prefers-color-scheme: dark) {
            :root:not(.light) {
                --background: #10131b;
                --surface: #181c23;
                --text: #c1c6d7;
                --border: #414754;
                --input: #0f1218;
            }
        }
        :root.dark {
            --background: #10131b;
            --surface: #181c23;
            --text: #c1c6d7;
            --border: #414754;
            --input: #0f1218;
        }
        * { box-sizing: border-box; }
        body {
            background: var(--background);
            color: var(--text);
            font-family: sans-serif;
            line-height: 1.5;
            margin: 0;
            padding: 24px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }
        h1 { margin: 0; font-size: 1.8em; }
        main {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 24px;
            max-width: 1600px;
            margin: 0 auto;
        }
        section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            min-width: 0;
        }
        h2 {
            margin-top: 0;
            border-bottom: 1px solid var(--border);
            padding-bottom: 12px;
            font-size: 1.2em;
        }
        .font-group {
            background: var(--background);
            border: 1px solid var(--border);
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        .font-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-weight: bold;
        }
        input[type="color"] {
            width: 24px;
            height: 24px;
            border: none;
            background: none;
            padding: 0;
            margin-right: 8px;
            cursor: pointer;
        }
        label {
            display: block;
            margin-bottom: 12px;
            font-size: 0.9em;
            opacity: 0.9;
        }
        input:not([type="color"]), textarea, select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--input);
            color: var(--text);
            margin-top: 4px;
            font-family: inherit;
        }
        textarea { resize: vertical; min-height: 60px; }
        .row { display: flex; gap: 12px; }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }
        .controls select { width: auto; }
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: auto;
        }
        button:hover { opacity: 0.9; }
        #previewContainer {
            background: var(--input);
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: auto;
            margin-bottom: 24px;
        }
        #canvasContainer {
            padding: 15px;
            display: flex;
            align-items: flex-start;
        }
        canvas { transform-origin: top left; display: block; flex-shrink: 0; }
        .results { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .result-card {
            background: var(--background);
            border: 1px solid var(--border);
            padding: 16px;
            border-radius: 6px;
        }
        .result-text {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9em;
            margin-top: 8px;
        }
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 8px;
        }
        @media (max-width: 900px) { main { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <header>
        <h1>Typographic Density Tool</h1>
        <select id="themeSelector" style="width:auto">
            <option value="auto">Auto Theme</option>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
        </select>
    </header>
    <main>
        <section>
            <h2>Configuration</h2>
            <div class="font-group">
                <div class="font-header">
                    <input type="color" id="font1Color" value="#00a2a2"> Font 1
                </div>
                <label>Font File <input type="file" id="font1File" accept=".otf,.ttf,.woff"></label>
                <label>Text <textarea id="font1Text" maxlength="1000">Idealogy</textarea></label>
                <label>Size (px) <input type="number" id="font1Size" value="100" min="8" max="500"></label>
                <div class="row">
                    <label>Letter Spacing <input type="number" id="font1Spacing" value="0" min="-100" max="100"></label>
                    <label>Baseline Shift <input type="number" id="font1Shift" value="0" min="-200" max="200"></label>
                </div>
            </div>
            <div class="font-group">
                <div class="font-header">
                    <input type="color" id="font2Color" value="#ff00ff"> Font 2
                </div>
                <label>Font File <input type="file" id="font2File" accept=".otf,.ttf,.woff"></label>
                <label>Text <textarea id="font2Text" maxlength="1000">Идеология</textarea></label>
                <label>Size (px) <input type="number" id="font2Size" value="100" min="8" max="500"></label>
                <div class="row">
                    <label>Letter Spacing <input type="number" id="font2Spacing" value="0" min="-100" max="100"></label>
                    <label>Baseline Shift <input type="number" id="font2Shift" value="0" min="-200" max="200"></label>
                </div>
            </div>
        </section>
        <section>
            <h2>Visualization</h2>
            <div class="controls">
                <select id="zoomMode"><option value="fit">Fit to View</option><option value="100">100% Scale</option></select>
                <select id="renderMode"><option value="overlay">Overlay</option><option value="side-by-side">Side-by-side</option></select>
                <select id="densityMode"><option value="ink-box">Ink Box</option><option value="em-box">Em Box</option></select>
                <button id="exportButton">Export PNG</button>
            </div>
            <div id="previewContainer">
                <div id="canvasContainer">
                    <canvas id="mainCanvas"></canvas>
                </div>
            </div>
            <div class="results">
                <div class="result-card">
                    <div class="font-header"><div id="result1Color" class="indicator"></div>Font 1 Analysis</div>
                    <div id="result1Text" class="result-text">Load a font.</div>
                </div>
                <div class="result-card">
                    <div class="font-header"><div id="result2Color" class="indicator"></div>Font 2 Analysis</div>
                    <div id="result2Text" class="result-text">Load a font.</div>
                </div>
            </div>
        </section>
    </main>
    <script>
        class DensityTool {
            constructor() {
                this.elements = {};
                document.querySelectorAll('[id]').forEach(element => this.elements[element.id] = element);

                this.applicationState = {
                    theme: 'auto',
                    loadedFonts: [null, null],
                    analyses: [null, null],
                    colors: [this.elements.font1Color.value, this.elements.font2Color.value],
                    animationFrames: {},
                    graphWidth: 150,
                    graphPadding: 20
                };

                this.context = this.elements.mainCanvas.getContext('2d');
                this.tintCanvas = document.createElement('canvas');
                this.tintContext = this.tintCanvas.getContext('2d', { willReadFrequently: true });

                this.fontInputs = [1, 2].map(i => ({
                    file: this.elements[`font${i}File`],
                    text: this.elements[`font${i}Text`],
                    size: this.elements[`font${i}Size`],
                    spacing: this.elements[`font${i}Spacing`],
                    shift: this.elements[`font${i}Shift`],
                    color: this.elements[`font${i}Color`],
                    result: this.elements[`result${i}Text`],
                    indicator: this.elements[`result${i}Color`]
                }));

                this.addListeners();
                this.update();
            }

            addListeners() {
                const schedule = (key, callback) => () => {
                    if (this.applicationState.animationFrames[key]) cancelAnimationFrame(this.applicationState.animationFrames[key]);
                    this.applicationState.animationFrames[key] = requestAnimationFrame(callback);
                };

                const refresh = schedule('refresh', () => this.update());
                const resize = schedule('resize', () => this.updateScale());

                this.elements.zoomMode.addEventListener('change', resize);
                this.elements.renderMode.addEventListener('change', refresh);
                this.elements.densityMode.addEventListener('change', refresh);
                this.elements.exportButton.addEventListener('click', () => this.exportImage());
                this.elements.themeSelector.addEventListener('change', (event) => this.setTheme(event.target.value));
                window.addEventListener('resize', resize);

                this.fontInputs.forEach((input, index) => {
                    input.file.addEventListener('change', (event) => this.loadFont(event.target.files[0], index));
                    input.color.addEventListener('input', (event) => {
                        this.applicationState.colors[index] = event.target.value;
                        refresh();
                    });
                    [input.text, input.size, input.spacing, input.shift].forEach(element => element.addEventListener('input', refresh));
                });

                this.setTheme('auto');
            }

            setTheme(theme) {
                const root = document.documentElement;
                root.classList.remove('light', 'dark');
                if (theme !== 'auto') root.classList.add(theme);
                this.elements.themeSelector.value = theme;
            }

            async loadFont(file, index) {
                if (!file) return;
                if (file.size > 30 * 1024 * 1024) return alert('File too large');
                try {
                    const buffer = await file.arrayBuffer();
                    const font = opentype.parse(buffer);
                    if (!font.draw) throw new Error('Invalid font');
                    this.applicationState.loadedFonts[index] = font;
                    this.update();
                } catch (error) {
                    alert(error.message);
                }
            }

            computeFontMetrics(fontFace, text, fontSize, letterSpacing) {
                const scale = fontSize / fontFace.unitsPerEm;
                const {os2, hhea} = fontFace.tables;

                const getMetric = (keys, transform=v=>v) => Math.max(...keys.map(key => transform(fontFace[key] ?? os2?.[key] ?? hhea?.[key] ?? 0))) * scale;

                const glyphs = fontFace.stringToGlyphs(text);
                const verticalExtents = glyphs.reduce((result, glyph) => {
                    const path = glyph.path;
                    if (!path?.getBoundingBox) return result;
                    const bounds = path.getBoundingBox();
                    if (!isFinite(bounds.y1) || !isFinite(bounds.y2)) return result;
                    result.actualAscent = Math.max(result.actualAscent, bounds.y2);
                    result.actualDescent = Math.max(result.actualDescent, -bounds.y1);
                    return result;
                }, {actualAscent: 0, actualDescent: 0});

                const fontAscent = getMetric(['ascender', 'sTypoAscender', 'usWinAscent']);
                const fontDescent = getMetric(['descender', 'sTypoDescender', 'usWinDescent'], Math.abs);

                const scaledAscent = verticalExtents.actualAscent * scale || fontFace.ascender * scale;
                const scaledDescent = verticalExtents.actualDescent * scale || Math.abs(fontFace.descender * scale);

                const pathOptions = {tracking: letterSpacing || 0};
                const textBounds = fontFace.getPath(text, 0, 0, fontSize, pathOptions).getBoundingBox();

                return {
                    ascent: Math.max(scaledAscent, fontAscent),
                    descent: Math.max(scaledDescent, fontDescent),
                    actualAscent: scaledAscent,
                    actualDescent: scaledDescent,
                    fontAscent,
                    fontDescent,
                    boundingBoxWidth: Math.ceil(textBounds.x2 - textBounds.x1),
                    advanceWidth: Math.ceil(fontFace.getAdvanceWidth(text, fontSize, pathOptions))
                };
            }

            analyze(fontFace, text, fontSize, baselineShift, letterSpacing) {
                if (!fontFace || !text || !fontSize) return null;

                const clampedSize = Math.max(1, Math.min(fontSize, 2000));
                const metrics = this.computeFontMetrics(fontFace, text, clampedSize, letterSpacing);

                if (!metrics?.advanceWidth || !isFinite(metrics.advanceWidth) || metrics.advanceWidth <= 0) return null;

                const baseline = Math.ceil(metrics.ascent);
                const offscreenCanvas = Object.assign(document.createElement('canvas'), {
                    width: metrics.advanceWidth,
                    height: Math.ceil(metrics.ascent + metrics.descent)
                });
                const offscreenContext = offscreenCanvas.getContext('2d');

                fontFace.draw(offscreenContext, text, 0, baseline, clampedSize, {tracking: letterSpacing || 0});

                const pixelAnalysis = this.analyzePixels(offscreenCanvas);
                if (pixelAnalysis.minimumY > pixelAnalysis.maximumY) return null;

                const density = this.computeDensity(pixelAnalysis, metrics, clampedSize);

                return {
                    ...pixelAnalysis,
                    ...metrics,
                    canvas: offscreenCanvas,
                    baseline,
                    baselineShift,
                    letterSpacing,
                    fontSize: clampedSize,
                    fontFace,
                    density: density.toFixed(1),
                    yMin: Math.round(baseline - pixelAnalysis.maximumY),
                    yMax: Math.round(baseline - pixelAnalysis.minimumY)
                };
            }

            analyzePixels(canvas) {
                const context = canvas.getContext('2d', {willReadFrequently: true});
                const {data, width, height} = context.getImageData(0, 0, canvas.width, canvas.height);

                const densityByRow = new Float32Array(height);
                let inkPixelCount = 0;
                let minimumX = width;
                let maximumX = -1;
                let minimumY = height;
                let maximumY = -1;

                for (let y = 0; y < height; y++) {
                    for (let x = 0, alphaIndex = y * width * 4 + 3; x < width; x++, alphaIndex += 4) {
                        if (data[alphaIndex] >= 128) {
                            if (y < minimumY) minimumY = y;
                            if (y > maximumY) maximumY = y;
                            if (x < minimumX) minimumX = x;
                            if (x > maximumX) maximumX = x;
                            inkPixelCount++;
                            densityByRow[y]++;
                        }
                    }
                }

                return {densityByRow, inkPixelCount, minimumX, maximumX, minimumY, maximumY};
            }

            computeDensity(pixelAnalysis, metrics, fontSize) {
                const width = (pixelAnalysis.maximumX - pixelAnalysis.minimumX + 1) || 1;
                const height = (pixelAnalysis.maximumY - pixelAnalysis.minimumY + 1) || 1;
                const area = this.elements.densityMode.value === 'ink-box' ? width * height : metrics.advanceWidth * fontSize;
                return (pixelAnalysis.inkPixelCount / area) * 100;
            }

            update() {
                this.applicationState.analyses = this.fontInputs.map((input, index) => {
                    input.indicator.style.backgroundColor = this.applicationState.colors[index];
                    return this.analyze(
                        this.applicationState.loadedFonts[index],
                        input.text.value.trim(),
                        Number(input.size.value) || 0,
                        Number(input.shift.value) || 0,
                        Number(input.spacing.value) || 0
                    );
                });

                this.draw();
                this.updateResults();
            }

            draw() {
                const analyses = this.applicationState.analyses.filter(Boolean);
                if (!analyses.length) {
                    this.renderEmpty();
                    return;
                }

                const dimensions = this.computeCanvasDimensions(analyses);
                this.elements.mainCanvas.width = dimensions.width;
                this.elements.mainCanvas.height = dimensions.height;
                this.context.clearRect(0, 0, dimensions.width, dimensions.height);

                const renderSideBySide = this.elements.renderMode.value === 'side-by-side' && analyses.length > 1;
                let textX = this.applicationState.graphWidth + this.applicationState.graphPadding;

                analyses.forEach((analysis, index) => {
                    const yOffset = dimensions.baseline - analysis.baseline - analysis.baselineShift;
                    const blendWithPrevious = this.applicationState.analyses.every(Boolean) && index > 0;
                    const color = this.applicationState.colors[this.applicationState.analyses.indexOf(analysis)];

                    this.renderDensityGraph(analysis, color, yOffset, blendWithPrevious);
                    this.renderGlyphs(analysis, color, textX, yOffset, blendWithPrevious);
                    if (renderSideBySide) textX += analysis.canvas.width;
                });

                this.updateScale();
            }

            computeCanvasDimensions(analyses) {
                const sideBySide = this.elements.renderMode.value === 'side-by-side' && analyses.length > 1;
                const maximumAscent = Math.max(0, ...analyses.map(a => a.baseline - a.baselineShift));
                const maximumDescent = Math.max(0, ...analyses.map(a => a.canvas.height - a.baseline + a.baselineShift));
                const textWidth = sideBySide ? analyses.reduce((sum, a) => sum + a.canvas.width, 0) : Math.max(0, ...analyses.map(a => a.canvas.width));

                return {
                    width: Math.ceil(this.applicationState.graphWidth + this.applicationState.graphPadding + textWidth),
                    height: Math.ceil(maximumAscent + maximumDescent),
                    baseline: Math.ceil(maximumAscent)
                };
            }

            renderDensityGraph(analysis, color, yOffset, blendWithPrevious) {
                const {densityByRow} = analysis;
                const maximumDensity = Math.max(1, ...densityByRow);

                this.context.fillStyle = color;
                this.context.globalCompositeOperation = blendWithPrevious ? 'multiply' : 'source-over';

                densityByRow.forEach((value, rowIndex) => {
                    if (!value) return;
                    const barWidth = (value / maximumDensity) * this.applicationState.graphWidth;
                    this.context.fillRect(this.applicationState.graphWidth - barWidth, rowIndex + yOffset, barWidth, 1);
                });

                this.context.globalCompositeOperation = 'source-over';
            }

            renderGlyphs(analysis, color, xOffset, yOffset, blendWithPrevious) {
                const {canvas} = analysis;

                this.tintCanvas.width = canvas.width;
                this.tintCanvas.height = canvas.height;

                this.tintContext.globalCompositeOperation = 'source-over';
                this.tintContext.fillStyle = color;
                this.tintContext.fillRect(0, 0, canvas.width, canvas.height);
                this.tintContext.globalCompositeOperation = 'destination-in';
                this.tintContext.drawImage(canvas, 0, 0);

                this.context.globalCompositeOperation = blendWithPrevious ? 'multiply' : 'source-over';
                this.context.drawImage(this.tintCanvas, xOffset, yOffset);
                this.context.globalCompositeOperation = 'source-over';
            }

            renderEmpty() {
                this.elements.mainCanvas.height = 150;
                this.context.clearRect(0, 0, this.elements.mainCanvas.width, this.elements.mainCanvas.height);
                this.updateScale();
            }

            updateScale() {
                const canvas = this.elements.mainCanvas;
                const container = this.elements.canvasContainer;
                const preview = this.elements.previewContainer;
                const fitToView = this.elements.zoomMode.value === 'fit' && canvas.width;

                canvas.style.transform = 'none';
                container.style.width = '';
                container.style.height = '';
                container.style.overflow = '';

                if (!fitToView) return;

                const styles = getComputedStyle(container);
                const paddingX = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
                const paddingY = parseFloat(styles.paddingTop) + parseFloat(styles.paddingBottom);
                const availableWidth = preview.clientWidth - paddingX;
                const scale = Math.min(availableWidth / canvas.width, 1);

                canvas.style.transform = `scale(${scale})`;
                container.style.width = `${canvas.width * scale + paddingX}px`;
                container.style.height = `${canvas.height * scale + paddingY}px`;
                container.style.overflow = 'hidden';
            }

            updateResults() {
                this.fontInputs.forEach((input, index) => {
                    const analysis = this.applicationState.analyses[index];
                    input.result.textContent = analysis ?
                        `Density: ${analysis.density}%\n\nInk Bounds:\n- Min Y: ${analysis.yMin}\n- Max Y: ${analysis.yMax}\n\nMetrics:\n- Ascent: ${Math.round(analysis.fontAscent)}\n- Descent: ${Math.round(analysis.fontDescent)}`
                        : (this.applicationState.loadedFonts[index] ? 'Enter text.' : 'Load font.');
                });
            }

            exportImage() {
                const link = document.createElement('a');
                link.href = this.elements.mainCanvas.toDataURL();
                link.download = 'density.png';
                link.click();
            }
        }
        new DensityTool();
    </script>
</body>
</html>