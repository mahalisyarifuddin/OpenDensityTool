<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Typographic Density Tool</title>
		<script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
		<style>
			:root {
				--primary-color: #0070ea;
				--primary-color-hover: #005bc0;
				--background: #f7f7f8;
				--background-container: #fff;
				--text-color: #333;
				--border-color: #e0e0e0;
				--panel-background: #fdfdfd;
				--font-one-color: rgba(0,162,162,0.9);
				--font-two-color: rgba(255,0,255,0.9);
				--input-background: #fff
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--background: #10131b;
					--background-container: #181c23;
					--text-color: #c1c6d7;
					--border-color: #414754;
					--panel-background: #1a1e26;
					--input-background: #0f1218
				}
			}

			:root.dark {
				--background: #10131b;
				--background-container: #181c23;
				--text-color: #c1c6d7;
				--border-color: #414754;
				--panel-background: #1a1e26;
				--input-background: #0f1218
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				background: var(--bkg);
				color: var(--text);
				font-family: sans-serif;
				line-height: 1.6;
				padding: 24px
			}

			.header {
				text-align: center;
				margin-bottom: 32px
			}

			.header h1 {
				font-size: 2em;
				font-weight: 600
			}

			.container {
				display: grid;
				grid-template-columns: 360px 1fr;
				gap: 24px;
				max-width: 1500px;
				margin: 0 auto
			}

			.panel {
				background: var(--bkg-container);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 24px
			}

			.panel-title {
				margin: 0 0 24px;
				font-size: 1.2em;
				font-weight: 600;
				border-bottom: 1px solid var(--border);
				padding-bottom: 12px
			}

			.font-section,
			.result-card {
				padding: 16px;
				border-radius: 6px;
				background: var(--panel-bkg);
				border: 1px solid var(--border)
			}

			.font-section {
				margin-bottom: 20px
			}

			.font-header,
			.result-header {
				display: flex;
				align-items: center;
				font-weight: 600;
				margin-bottom: 16px
			}

			.color-indicator {
				width: 16px;
				height: 16px;
				border-radius: 4px;
				margin-right: 10px;
				flex-shrink: 0
			}

			.font-one .color-indicator {
				background: var(--font-one-color)
			}

			.font-two .color-indicator {
				background: var(--font-two-color)
			}

			.form-field {
				margin-bottom: 16px
			}

			.form-field:last-child {
				margin-bottom: 0
			}

			.field-label {
				display: block;
				font-weight: 500;
				margin-bottom: 6px;
				font-size: .9em;
				color: var(--text-color);
				opacity: .85
			}

			.form-input,.controls-bar>* {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid var(--border-color);
				border-radius: 4px;
				font-size: .95em;
				background: var(--input-background);
				color: var(--text-color);
				transition: border-color .2s,box-shadow .2s
			}

			.controls-bar>* {
				width: auto;
				padding: 6px 10px;
				font-size: .9em
			}

			.form-input:focus {
				outline: none;
				border-color: var(--primary-color);
				box-shadow: 0 0 0 3px rgba(0,112,234,.15)
			}

			textarea.form-input {
				min-height: 80px;
				resize: vertical
			}

			.field-row {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 12px
			}

			.controls-bar {
				display: flex;
				align-items: center;
				gap: 12px;
				margin-bottom: 16px;
				flex-wrap: wrap
			}

			button {
				cursor: pointer;
				transition: background .2s
			}

			button:hover {
				opacity: .9
			}

			.button-primary {
				background: var(--primary-color);
				border: none;
				color: #fff
			}

			.button-primary:hover {
				background: var(--primary-hover)
			}

			.preview-container {
				background: var(--input-bkg);
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto
			}

			#canvas {
				display: block;
				transform-origin: top left;
				margin: 15px
			}

			.results-layout {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 16px;
				margin-top: 24px
			}

			.result-header {
				margin-bottom: 10px
			}

			.result-data {
				font-family: monospace;
				font-size: .95em;
				line-height: 1.5;
				background: var(--panel-bkg);
				padding: 10px;
				border-radius: 4px;
				white-space: pre-wrap;
				opacity: .9
			}

			#themeSelect {
				position: absolute;
				right: 24px;
				top: 24px;
				font-size: .9rem;
				padding: 5px;
				width: auto;
				background: var(--bkg-container)
			}

			@media(max-width: 900px) {
				.container {
					grid-template-columns: 1fr
				}
			}

			@media(max-width: 500px) {
				.results-layout {
					grid-template-columns: 1fr
				}

				body {
					padding: 16px
				}

				#themeSelect {
					right: 16px;
					top: 16px
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>Typographic Density Tool</h1>
			<div class="theme-select">
				<select id="themeSelect">
					<option value="auto">Auto Theme</option>
					<option value="light">Light</option>
					<option value="dark">Dark</option>
				</select>
			</div>
		</div>
		<div class="container">
			<div class="panel">
				<h2 class="panel-title">Font Configuration</h2>
				<div class="font-section font-one">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 1 (Cyan)
					
					</div>
					<div class="form-field">
						<label class="field-label" for="font1-file">Font File</label>
						<input type="file" id="font1-file" class="form-input" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-field">
						<label class="field-label" for="font1-text">Text</label>
						<textarea id="font1-text" class="form-input" placeholder="Enter text to analyze" maxlength="1000">Idealogy</textarea>
					</div>
					<div class="form-field">
						<label class="field-label" for="font1-size">Size (px)</label>
						<input type="number" id="font1-size" class="form-input" value="100" min="8" max="500"/>
					</div>
					<div class="field-row">
						<div class="form-field">
							<label class="field-label" for="font1-letter-spacing">Letter Spacing</label>
							<input type="number" id="font1-letter-spacing" class="form-input" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-field">
							<label class="field-label" for="font1-shift">Baseline Shift</label>
							<input type="number" id="font1-shift" class="form-input" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
				<div class="font-section font-two">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 2 (Magenta)
					
					</div>
					<div class="form-field">
						<label class="field-label" for="font2-file">Font File</label>
						<input type="file" id="font2-file" class="form-input" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-field">
						<label class="field-label" for="font2-text">Text</label>
						<textarea id="font2-text" class="form-input" placeholder="Enter text to analyze" maxlength="1000">Идеология</textarea>
					</div>
					<div class="form-field">
						<label class="field-label" for="font2-size">Size (px)</label>
						<input type="number" id="font2-size" class="form-input" value="100" min="8" max="500"/>
					</div>
					<div class="field-row">
						<div class="form-field">
							<label class="field-label" for="font2-letter-spacing">Letter Spacing</label>
							<input type="number" id="font2-letter-spacing" class="form-input" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-field">
							<label class="field-label" for="font2-shift">Baseline Shift</label>
							<input type="number" id="font2-shift" class="form-input" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
			</div>
			<div class="panel">
				<h2 class="panel-title">Visualization and Analysis</h2>
				<div class="controls-bar">
					<select id="zoom-mode">
						<option value="fit">Fit to View</option>
						<option value="100">100% Scale</option>
					</select>
					<select id="render-mode">
						<option value="overlay">Overlay</option>
						<option value="side-by-side">Side-by-side</option>
					</select>
					<select id="density-mode">
						<option value="ink-box">Ink Box</option>
						<option value="em-box">Em box</option>
					</select>
					<button id="export-png" class="button-primary" style="margin-left: auto;">Export PNG</button>
				</div>
				<div class="preview-container">
					<div class="canvas-container">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results-section">
					<div class="results-layout">
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font-one-color)"></div>
								Font 1 Analysis
							
							</div>
							<div id="results1" class="result-data">Load a font to see analysis.</div>
						</div>
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font-two-color)"></div>
								Font 2 Analysis
							
							</div>
							<div id="results2" class="result-data">Load a font to see analysis.</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script>
			const qs = (selector,scope=document)=>scope.querySelector(selector);
			const ce = type=>document.createElement(type);

			class DensityTool {
				constructor() {
					this.initializeState();
					this.bindEventListeners();
					this.applyTheme();
					this.render();
				}

				initializeState() {
					const styles = getComputedStyle(document.documentElement);
					this.state = {
						theme: 'auto',
						fonts: [null, null],
						analyses: [null, null],
						colors: ['--font-one-color', '--font-two-color'].map(prop=>styles.getPropertyValue(prop).trim()),
						animationRefs: {}
					};

					this.config = {
						graphWidth: 150,
						graphPadding: 20
					};

					this.elements = ['canvas', 'zoom-mode', 'render-mode', 'density-mode', 'export-png', 'themeSelect'].reduce((acc,id)=>(acc[id.replace(/-(\w)/g, (_, c)=>c.toUpperCase())] = qs(`#${id}`),
					acc), {});
					this.context = this.elements.canvas.getContext('2d');

					this.fontConfigs = [1, 2].map(i=>Object.fromEntries(['file', 'text', 'size', 'shift', 'letter-spacing', 'results'].map(type=>[type.replace(/-(\w)/g, (_, c)=>c.toUpperCase()), qs(`#font${i}-${type}`)])));

					this.tintCanvas = ce('canvas');
					this.tintContext = this.tintCanvas.getContext('2d', {
						willReadFrequently: true
					});
				}

				bindEventListeners() {
					const createQueuedCallback = (callback, key)=>(...args)=>{
						cancelAnimationFrame(this.state.animationRefs[key]);
						this.state.animationRefs[key] = requestAnimationFrame(()=>callback.apply(this, args));
					}
					;
					this.queueAnalysis = createQueuedCallback(this.analyzeAndRender, 'analyze');
					this.queueScaling = createQueuedCallback(this.updateDisplayScale, 'scale');

					const UIElements = {
						zoomMode: this.queueScaling,
						renderMode: this.queueAnalysis,
						densityMode: this.queueAnalysis
					};
					Object.entries(UIElements).forEach(([key,listener])=>this.elements[key].onchange = listener);

					this.elements.exportPng.onclick = ()=>this.exportImage();
					this.elements.themeSelect.onchange = e=>this.applyTheme(e.target.value);
					this.fontConfigs.forEach((config,index)=>{
						config.file.onchange = e=>this.handleFontLoad(e.target.files?.[0], index);
						Object.values(config).forEach(el=>{
							if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT' && el.type === 'number') {
								el.oninput = this.queueAnalysis;
								el.onchange = this.queueAnalysis;
							}
						}
						);
					}
					);
					window.onresize = this.queueScaling;
				}

				applyTheme(theme = this.state.theme) {
					this.state.theme = theme;
					document.documentElement.className = theme === 'auto' ? '' : theme;
				}

				async handleFontLoad(file, index) {
					const config = this.fontConfigs[index];
					let font = null;
					if (!file) {
						config.file.value = '';
					} else if (file.size > 30 * 1024 * 1024) {
						alert(`Font too large (${(file.size / 1048576).toFixed(1)}MB). Max 30MB.`);
						config.file.value = '';
					} else {
						try {
							const buffer = await file.arrayBuffer();
							font = opentype.parse(buffer);
							if (!font?.draw || !font.unitsPerEm)
								throw new Error('Invalid font.');
						} catch (error) {
							console.error('Font loading failed:', error);
							alert(`Failed to parse font: ${file.name}`);
							font = null;
						}
					}
					this.state.fonts[index] = font;
					if (!font)
						config.file.value = '';
					this.queueAnalysis();
				}

				calculateFontMetrics(font, text, fontSize, letterSpacing) {
					const scale = fontSize / font.unitsPerEm;
					const {os2, hhea} = font.tables;
					const getMetric = (keys,transform=v=>v)=>Math.max(...keys.map(key=>transform(font[key] ?? os2?.[key] ?? hhea?.[key] ?? 0))) * scale;
					const glyphs = font.stringToGlyphs(text);
					const actualAscent = Math.max(0, ...glyphs.map(g=>g.path?.getBoundingBox()?.y2 ?? 0));
					const actualDescent = Math.max(0, ...glyphs.map(g=>-(g.path?.getBoundingBox()?.y1 ?? 0)));
					const fontAscent = getMetric(['ascender', 'sTypoAscender', 'usWinAscent']);
					const fontDescent = getMetric(['descender', 'sTypoDescender', 'usWinDescent'], Math.abs);
					const scaledAscent = actualAscent * scale || font.ascender * scale;
					const scaledDescent = actualDescent * scale || Math.abs(font.descender * scale);
					const pathOptions = {
						tracking: letterSpacing || 0
					};
					const pathBbox = font.getPath(text, 0, 0, fontSize, pathOptions).getBoundingBox();
					return {
						ascent: Math.max(scaledAscent, fontAscent),
						descent: Math.max(scaledDescent, fontDescent),
						actualAscent: scaledAscent,
						actualDescent: scaledDescent,
						fontAscent,
						fontDescent,
						bboxWidth: Math.ceil(pathBbox.x2 - pathBbox.x1),
						advanceWidth: Math.ceil(font.getAdvanceWidth(text, fontSize, pathOptions))
					};
				}

				analyzeFont(font, text, fontSize, baselineShift, letterSpacing) {
					if (!font || !text || !fontSize)
						return null;
					const clampedSize = Math.max(1, Math.min(fontSize, 2000));
					const metrics = this.calculateFontMetrics(font, text, clampedSize, letterSpacing);
					if (!metrics?.advanceWidth || !isFinite(metrics.advanceWidth) || metrics.advanceWidth <= 0)
						return null;
					const baseline = Math.ceil(metrics.ascent);
					const canvas = Object.assign(document.createElement('canvas'), {
						width: metrics.advanceWidth,
						height: Math.ceil(metrics.ascent + metrics.descent)
					});
					font.draw(canvas.getContext('2d'), text, 0, baseline, clampedSize, {
						tracking: letterSpacing || 0
					});
					const pixelData = this.analyzePixelData(canvas);
					if (pixelData.minimumY > pixelData.maximumY)
						return null;
					const density = this.calculateDensity(pixelData, metrics, clampedSize);
					return {
						...pixelData,
						...metrics,
						canvas,
						baseline,
						baselineShift,
						letterSpacing,
						fontSize: clampedSize,
						density: density.toFixed(1),
						yMin: Math.round(baseline - pixelData.maximumY),
						yMax: Math.round(baseline - pixelData.minimumY)
					};
				}

				analyzePixelData(canvas) {
					const {data, width, height} = canvas.getContext('2d', {
						willReadFrequently: true
					}).getImageData(0, 0, width, height);
					const densityMap = new Float32Array(height);
					let inkVolume = 0
					  , minX = width
					  , maxX = -1
					  , minY = height
					  , maxY = -1;
					for (let y = 0; y < height; ++y) {
						for (let x = 0, i = y * width * 4 + 3; x < width; ++x,
						i += 4) {
							if (data[i] > 128) {
								minY = Math.min(minY, y);
								maxY = Math.max(maxY, y);
								minX = Math.min(minX, x);
								maxX = Math.max(maxX, x);
								inkVolume++;
								densityMap[y]++;
							}
						}
					}
					return {
						densityMap,
						inkVolume,
						minimumX: minX,
						maximumX: maxX,
						minimumY: minY,
						maximumY: maxY
					};
				}

				calculateDensity({inkVolume, maximumX, minimumX, maximumY, minimumY}, metrics, fontSize) {
					const width = (maximumX - minimumX + 1) || 1;
					const height = (maximumY - minimumY + 1) || 1;
					const area = this.elements.densityMode.value === 'ink-box' ? width * height : metrics.advanceWidth * fontSize;
					return (inkVolume / area) * 100;
				}

				analyzeAndRender() {
					this.state.analyses = this.fontConfigs.map((config,index)=>this.analyzeFont(this.state.fonts[index], config.text.value.trim(), Number(config.size.value) || 0, Number(config.shift.value) || 0, Number(config.letterSpacing.value) || 0));
					const analyses = this.state.analyses.filter(Boolean);
					if (!analyses.length)
						return this.renderEmpty();
					const dims = this.calculateCanvasDimensions(analyses);
					Object.assign(this.elements.canvas, dims);
					this.context.clearRect(0, 0, dims.width, dims.height);
					const isSideBySide = this.elements.renderMode.value === 'side-by-side' && analyses.length > 1;
					let xOffset = this.config.graphWidth + this.config.graphPadding;
					analyses.forEach((analysis,index)=>{
						const yOffset = dims.baseline - analysis.baseline - analysis.baselineShift;
						const blend = this.state.analyses.every(Boolean) && index > 0;
						this.renderDensityGraph(analysis, this.state.colors[index], yOffset, blend);
						this.renderText(analysis, this.state.colors[index], xOffset, yOffset, blend);
						if (isSideBySide)
							xOffset += analysis.canvas.width;
					}
					);
					this.queueScaling();
					this.updateResults();
				}

				calculateCanvasDimensions(analyses) {
					const isSideBySide = this.elements.renderMode.value === 'side-by-side' && analyses.length > 1;
					const maxAscent = Math.max(0, ...analyses.map(a=>a.baseline - a.baselineShift));
					const maxDescent = Math.max(0, ...analyses.map(a=>a.canvas.height - a.baseline + a.baselineShift));
					const totalWidth = isSideBySide ? analyses.reduce((sum,a)=>sum + a.canvas.width, 0) : Math.max(0, ...analyses.map(a=>a.canvas.width));
					return {
						width: Math.ceil(this.config.graphWidth + this.config.graphPadding + totalWidth),
						height: Math.ceil(maxAscent + maxDescent),
						baseline: Math.ceil(maxAscent)
					};
				}

				renderDensityGraph({densityMap}, color, yOffset, shouldBlend) {
					const maxDensity = Math.max(1, ...densityMap);
					this.context.fillStyle = color;
					this.context.globalCompositeOperation = shouldBlend ? 'multiply' : 'source-over';
					densityMap.forEach((val,i)=>{
						if (val > 0) {
							const barWidth = (val / maxDensity) * this.config.graphWidth;
							this.context.fillRect(this.config.graphWidth - barWidth, i + yOffset, barWidth, 1);
						}
					}
					);
					this.context.globalCompositeOperation = 'source-over';
				}

				renderText({canvas}, color, x, y, blend) {
					Object.assign(this.tintCanvas, {
						width: canvas.width,
						height: canvas.height
					});
					this.tintContext.fillStyle = color;
					this.tintContext.fillRect(0, 0, canvas.width, canvas.height);
					this.tintContext.globalCompositeOperation = 'destination-in';
					this.tintContext.drawImage(canvas, 0, 0);
					this.context.globalCompositeOperation = blend ? 'multiply' : 'source-over';
					this.context.drawImage(this.tintCanvas, x, y);
					this.context.globalCompositeOperation = 'source-over';
					this.tintContext.globalCompositeOperation = 'source-over';
				}

				renderEmpty() {
					Object.assign(this.elements.canvas, {
						width: 400,
						height: 150
					});
					this.context.clearRect(0, 0, this.elements.canvas.width, this.elements.canvas.height);
					this.queueScaling();
				}

				updateDisplayScale() {
					const {canvas} = this.elements;
					const container = canvas.parentElement;
					const isFit = this.elements.zoomMode.value === 'fit' && canvas.width > 0;
					canvas.style.transform = '';
					container.style.cssText = '';
					if (!isFit)
						return;
					const padH = parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight);
					const padV = parseFloat(getComputedStyle(container).paddingTop) + parseFloat(getComputedStyle(container).paddingBottom);
					const scale = Math.min((container.parentElement.clientWidth - padH) / canvas.width, 1);
					canvas.style.transform = `scale(${scale})`;
					container.style.width = `${canvas.width * scale + padH}px`;
					container.style.height = `${canvas.height * scale + padV}px`;
					container.style.overflow = 'hidden';
				}

				updateResults() {
					this.fontConfigs.forEach((config,i)=>{
						const analysis = this.state.analyses[i];
						let content = 'Load a font to see analysis.';
						if (this.state.fonts[i] && !analysis) {
							content = 'Enter text to analyze.';
						} else if (analysis) {
							const format = key=>`${key.replace(/([A-Z])/g, ' $1').replace(/^\w/, c=>c.toUpperCase())}: ${Math.round(analysis[key])}px`;
							const metrics = Object.keys(analysis).filter(key=>key.includes('Ascent') || key.includes('Descent')).map(format);
							content = [`Y Min: ${analysis.yMin}px`, `Y Max: ${analysis.yMax}px`, `Density: ${analysis.density}%`, `Font Size: ${analysis.fontSize}px`, `Baseline Shift: ${analysis.baselineShift}px`, `Letter Spacing: ${analysis.letterSpacing}px`, ...metrics].join('\n');
						}
						config.results.textContent = content;
					}
					);
				}

				exportImage() {
					Object.assign(ce('a'), {
						href: this.elements.canvas.toDataURL('image/png'),
						download: 'typographic-density.png'
					}).click();
				}
			}

			document.addEventListener('DOMContentLoaded', ()=>new DensityTool());
		</script>
	</body>
</html>
