<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Typographic Density Tool</title>
		<script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.js"></script>
		<style>
			:root {
				--bg: #f7f7f8;
				--text: #333;
				--border: #e0e0e0;
				--panel: #ffffff;
				--font1: rgba(0,162,162,0.9);
				--font2: rgba(255,0,255,0.9);
				--accent: #0066cc;
			}

			* {
				box-sizing: border-box;
			}

			body {
				font-family: sans-serif;
				margin: 0;
				padding: 24px;
				background: var(--bg);
				color: var(--text);
				line-height: 1.6;
			}

			.header {
				text-align: center;
				margin-bottom: 32px;
			}

			.header h1 {
				margin: 0;
				font-size: 2em;
				font-weight: 600;
			}

			.container {
				display: grid;
				grid-template-columns: 360px 1fr;
				gap: 24px;
				max-width: 1500px;
				margin: 0 auto;
			}

			.panel {
				background: var(--panel);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 24px;
				min-width: 0;
			}

			.panel-title {
				margin: 0 0 24px;
				font-size: 1.2em;
				font-weight: 600;
				border-bottom: 1px solid var(--border);
				padding-bottom: 12px;
			}

			.font-section {
				padding: 16px;
				margin-bottom: 20px;
				border-radius: 6px;
				background: #fdfdfd;
				border: 1px solid var(--border);
			}

			.font-header {
				display: flex;
				align-items: center;
				margin: 0 0 16px;
				font-weight: 600;
			}

			.color-indicator {
				width: 16px;
				height: 16px;
				border-radius: 4px;
				margin-right: 10px;
				flex: 0 0 16px;
			}

			.font1 .color-indicator {
				background: var(--font1);
			}

			.font2 .color-indicator {
				background: var(--font2);
			}

			.form-group {
				margin-bottom: 16px;
			}

			.form-group:last-child {
				margin-bottom: 0;
			}

			.form-label {
				display: block;
				font-weight: 500;
				margin-bottom: 6px;
				font-size: 0.9em;
				color: #555;
			}

			.form-control {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid #ccc;
				border-radius: 4px;
				font-size: 0.95em;
				background: #fff;
				transition: border-color .2s,box-shadow .2s;
			}

			.form-control:focus {
				outline: none;
				border-color: var(--accent);
				box-shadow: 0 0 0 3px rgba(0,102,204,.15);
			}

			textarea.form-control {
				min-height: 80px;
				resize: vertical;
			}

			.form-row {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 12px;
			}

			.controls-bar {
				display: flex;
				align-items: center;
				gap: 12px;
				margin-bottom: 16px;
				flex-wrap: wrap;
			}

			.control-group {
				display: flex;
				align-items: center;
				gap: 6px;
			}

			.zoom-label {
				font-weight: 500;
				font-size: 0.9em;
				color: #555;
			}

			.zoom-select {
				padding: 6px 10px;
				border: 1px solid #ccc;
				border-radius: 4px;
				font-size: 0.9em;
				background: #fff;
			}

			.preview-container {
				background: #fff;
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto;
			}

			.canvas-wrapper {
				padding: 20px;
				display: flex;
				justify-content: flex-start;
				align-items: flex-start;
			}

			#canvas {
				display: block;
				transform-origin: top left;
			}

			.results-section {
				margin-top: 24px;
			}

			.results-grid {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 16px;
			}

			.result-card {
				border: 1px solid var(--border);
				border-radius: 6px;
				padding: 16px;
				background: #fdfdfd;
			}

			.result-header {
				display: flex;
				align-items: center;
				margin: 0 0 10px;
				font-weight: 600;
			}

			.result-data {
				font-family: monospace;
				font-size: 0.95em;
				line-height: 1.5;
				color: #444;
				background: #f0f0f0;
				padding: 10px;
				border-radius: 4px;
				white-space: pre-wrap;
			}

			@media (max-width: 900px) {
				.container {
					grid-template-columns:1fr;
				}
			}

			@media (max-width: 500px) {
				.results-grid {
					grid-template-columns:1fr;
				}

				body {
					padding: 16px;
				}
			}
		</style>
	</head>
	<body>
		<div class="header">
			<h1>Typographic Density Tool</h1>
		</div>
		<div class="container">
			<div class="panel">
				<h2 class="panel-title">Font Configuration</h2>
				<div class="font-section font1">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 1 (Cyan)
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-file">Font File</label>
						<input type="file" id="font1-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-text">Text</label>
						<textarea id="font1-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Idealogy</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font1-size">Size (px)</label>
						<input type="number" id="font1-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font1-letter-spacing">Letter Spacing</label>
							<input type="number" id="font1-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font1-shift">Baseline Shift</label>
							<input type="number" id="font1-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
				<div class="font-section font2">
					<div class="font-header">
						<div class="color-indicator"></div>
						Font 2 (Magenta)
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-file">Font File</label>
						<input type="file" id="font2-file" class="form-control" accept=".otf,.ttf,.woff"/>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-text">Text</label>
						<textarea id="font2-text" class="form-control" placeholder="Enter text to analyze" maxlength="1000">Идеология</textarea>
					</div>
					<div class="form-group">
						<label class="form-label" for="font2-size">Size (px)</label>
						<input type="number" id="font2-size" class="form-control" value="100" min="8" max="500"/>
					</div>
					<div class="form-row">
						<div class="form-group">
							<label class="form-label" for="font2-letter-spacing">Letter Spacing</label>
							<input type="number" id="font2-letter-spacing" class="form-control" value="0" min="-100" max="100" step="1"/>
						</div>
						<div class="form-group">
							<label class="form-label" for="font2-shift">Baseline Shift</label>
							<input type="number" id="font2-shift" class="form-control" value="0" min="-200" max="200"/>
						</div>
					</div>
				</div>
			</div>
			<div class="panel">
				<h2 class="panel-title">Visualization and Analysis</h2>
				<div class="controls-bar">
					<div class="control-group">
						<span class="zoom-label">Display:</span>
						<select id="zoom-mode" class="zoom-select">
							<option value="fit">Fit to View</option>
							<option value="100">100% Scale</option>
						</select>
					</div>
					<div class="control-group">
						<span class="zoom-label">Mode:</span>
						<select id="render-mode" class="zoom-select">
							<option value="overlay">Overlay</option>
							<option value="side-by-side">Side-by-side</option>
						</select>
					</div>
					<div class="control-group">
						<span class="zoom-label">Normalize by:</span>
						<select id="density-mode" class="zoom-select">
							<option value="glyph-bounds">Glyph Bounds</option>
							<option value="char-spacing">Character Spacing</option>
						</select>
					</div>
					<button id="export-png" class="zoom-select" style="margin-left: auto;">Export PNG</button>
				</div>
				<div class="preview-container">
					<div class="canvas-wrapper">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results-section">
					<div class="results-grid">
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font1)"></div>
								Font 1 Analysis
							</div>
							<div id="results1" class="result-data">Load a font to see analysis.</div>
						</div>
						<div class="result-card">
							<div class="result-header">
								<div class="color-indicator" style="background: var(--font2)"></div>
								Font 2 Analysis
							</div>
							<div id="results2" class="result-data">Load a font to see analysis.</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script>
			class FontDensityAnalyzer {
				constructor() {
					this.dom = this._selectDOMElements();
					this.config = this._getInitialConfig();
					this.state = {
						fonts: [null, null],
						analyses: [null, null],
						raf: {},
					};
					this.ctx = this.dom.canvas.getContext('2d');
					this.tintCanvas = document.createElement('canvas');
					this.tintCtx = this.tintCanvas.getContext('2d', { willReadFrequently: true });

					this._bindEvents();
					this.render();
				}

				_selectDOMElements() {
					const getEl = id => document.getElementById(id);
					const elements = {
						canvas: getEl('canvas'),
						zoomMode: getEl('zoom-mode'),
						renderMode: getEl('render-mode'),
						densityMode: getEl('density-mode'),
						exportBtn: getEl('export-png'),
						fontControls: [],
					};
					for (const i of [1, 2]) {
						elements.fontControls.push({
							file: getEl(`font${i}-file`),
							text: getEl(`font${i}-text`),
							size: getEl(`font${i}-size`),
							shift: getEl(`font${i}-shift`),
							letterSpacing: getEl(`font${i}-letter-spacing`),
							results: getEl(`results${i}`),
						});
					}
					return elements;
				}

				_getInitialConfig() {
					const css = getComputedStyle(document.documentElement);
					return {
						colors: ['--font1', '--font2'].map(p => css.getPropertyValue(p).trim()),
						graphWidth: 150,
						graphPadding: 20,
						maxFontSize: 30 * 1024 * 1024,
					};
				}

				_bindEvents() {
					const queue = (fn, key) => (...args) => {
						cancelAnimationFrame(this.state.raf[key]);
						this.state.raf[key] = requestAnimationFrame(() => fn.apply(this, args));
					};

					this.queueAnalyzeAndRender = queue(this.analyzeAndRender, 'analyze');
					this.queueUpdateDisplayScale = queue(this.updateDisplayScale, 'scale');

					this.dom.fontControls.forEach((controls, i) => {
						controls.file.addEventListener('change', e => this.loadFont(e.target.files?.[0], i));
						const analysisInputs = [controls.text, controls.size, controls.shift, controls.letterSpacing];
						analysisInputs.forEach(el => ['input', 'change'].forEach(evt => el.addEventListener(evt, this.queueAnalyzeAndRender)));
					});

					this.dom.zoomMode.addEventListener('change', this.queueUpdateDisplayScale);
					this.dom.renderMode.addEventListener('change', this.queueAnalyzeAndRender);
					this.dom.densityMode.addEventListener('change', this.queueAnalyzeAndRender);
					this.dom.exportBtn.addEventListener('click', () => this.exportPNG());
					window.addEventListener('resize', this.queueUpdateDisplayScale);
				}

				async loadFont(file, index) {
					const resetFont = () => {
						this.dom.fontControls[index].file.value = '';
						this.state.fonts[index] = null;
					};

					if (!file) return;

					if (file.size > this.config.maxFontSize) {
						const toMB = bytes => (bytes / 1024 / 1024).toFixed(1);
						alert(`Font file is too large (${toMB(file.size)}MB). Maximum size is ${toMB(this.config.maxFontSize)}MB.`);
						resetFont();
						return;
					}

					try {
						this.state.fonts[index] = opentype.parse(await file.arrayBuffer());
					} catch (err) {
						console.error('Font loading failed:', err);
						alert(`Failed to parse font: ${file.name}. The file may be corrupt or not a supported font format.`);
						resetFont();
					}
					this.queueAnalyzeAndRender();
				}

				getFontMetrics(font, text, fontSize, letterSpacing) {
					const scale = fontSize / font.unitsPerEm;
					const options = { tracking: letterSpacing || 0 };

					// Calculate actual ascent/descent from rendered glyphs
					let actualAscent = 0, actualDescent = 0;
					for (const glyph of font.stringToGlyphs(text)) {
						const b = glyph.path?.getBoundingBox();
						if (b && isFinite(b.y1) && isFinite(b.y2)) {
							actualAscent = Math.max(actualAscent, b.y2 * scale);
							actualDescent = Math.max(actualDescent, -b.y1 * scale);
						}
					}
					// Fallback if glyphs have no area
					if (actualAscent === 0 && actualDescent === 0) {
						actualAscent = font.ascender * scale;
						actualDescent = Math.abs(font.descender * scale);
					}

					// Get max ascent/descent from various font table metrics for a robust value
					const { os2, hhea } = font.tables;
					const ascMetrics = [font.ascender, os2?.sTypoAscender, os2?.usWinAscent, hhea?.ascender];
					const descMetrics = [font.descender, os2?.sTypoDescender, os2?.usWinDescent, hhea?.descender];
					const fontAscent = Math.max(...ascMetrics.filter(isFinite).map(m => m * scale));
					const fontDescent = Math.max(...descMetrics.filter(isFinite).map(m => Math.abs(m * scale)));

					const path = font.getPath(text, 0, 0, fontSize, options);
					const bounds = path.getBoundingBox();

					return {
						ascent: Math.max(actualAscent, fontAscent),
						descent: Math.max(actualDescent, fontDescent),
						actualAscent, actualDescent, fontAscent, fontDescent,
						bboxWidth: Math.ceil(bounds.x2 - bounds.x1),
						advanceWidth: Math.ceil(font.getAdvanceWidth(text, fontSize, options))
					};
				}

				analyzeFont(font, text, fontSize, baselineShift, letterSpacing) {
					if (!font || !text || !fontSize) return null;
					fontSize = Math.max(1, Math.min(fontSize, 2000));

					const metrics = this.getFontMetrics(font, text, fontSize, letterSpacing);
					if (!isFinite(metrics.bboxWidth) || metrics.bboxWidth <= 0) return null;

					const height = Math.ceil(metrics.ascent + metrics.descent);
					const baseline = Math.ceil(metrics.ascent);

					const tempCanvas = Object.assign(document.createElement('canvas'), { width: metrics.advanceWidth, height });
					font.draw(tempCanvas.getContext('2d'), text, 0, baseline, fontSize, { tracking: letterSpacing || 0 });

					const pixelAnalysis = this._getPixelAnalysis(tempCanvas);
					if (pixelAnalysis.minY > pixelAnalysis.maxY) return null;

					const density = this._calculateDensity(pixelAnalysis, metrics);

					return {
						yMin: Math.round(baseline - pixelAnalysis.maxY),
						yMax: Math.round(baseline - pixelAnalysis.minY),
						density: density.toFixed(1),
						densityMap: pixelAnalysis.densityMap,
						canvas: tempCanvas,
						baseline, baselineShift, letterSpacing, fontSize, font, metrics,
					};
				}

				_getPixelAnalysis(canvas) {
					const { data, width, height } = canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, canvas.width, canvas.height);
					const densityMap = new Float32Array(height);
					let inkVolume = 0, inkCoverage = 0;
					let minX = width, maxX = -1, minY = height, maxY = -1;

					for (let y = 0; y < height; y++) {
						for (let x = 0, i = ((y * width) << 2) + 3; x < width; x++, i += 4) {
							const alpha = data[i];
							if (alpha > 0) {
								minY = Math.min(minY, y);
								maxY = Math.max(maxY, y);
								minX = Math.min(minX, x);
								maxX = Math.max(maxX, x);

								const val = alpha / 255;
								inkVolume += val;
								densityMap[y] += val;
								inkCoverage++;
							}
						}
					}
					return { densityMap, inkVolume, inkCoverage, minX, maxX, minY, maxY };
				}

				_calculateDensity(pixelAnalysis, metrics) {
					if (this.dom.densityMode.value === 'glyph-bounds') {
						const w = (pixelAnalysis.maxX - pixelAnalysis.minX + 1) || 1;
						const h = (pixelAnalysis.maxY - pixelAnalysis.minY + 1) || 1;
						return (pixelAnalysis.inkCoverage / (w * h)) * 100;
					}
					const metricArea = metrics.advanceWidth * (metrics.ascent + metrics.descent);
					return (pixelAnalysis.inkVolume / metricArea) * 100;
				}

				analyzeAndRender() {
					this.state.analyses = this.dom.fontControls.map((c, i) =>
						this.analyzeFont(
							this.state.fonts[i],
							c.text.value.trim(),
							+c.size.value || 0,
							+c.shift.value || 0,
							+c.letterSpacing.value || 0
						)
					);
					this.render();
				}

				render() {
					const validAnalyses = this.state.analyses.filter(Boolean);
					if (!validAnalyses.length) {
						this._renderEmpty();
						this.updateResults();
						return;
					}

					const { width, height, baseline } = this._calculateCanvasDimensions(validAnalyses);
					Object.assign(this.dom.canvas, { width, height });
					this.ctx.clearRect(0, 0, width, height);

					const isSideBySide = this.dom.renderMode.value === 'side-by-side' && validAnalyses.length > 1;
					const useBlend = this.state.analyses[0] && this.state.analyses[1];
					let currentX = this.config.graphWidth + this.config.graphPadding;
					let lastAdvance = 0;

					this.state.analyses.forEach((analysis, i) => {
						if (!analysis) return;
						const yOffset = baseline - analysis.baseline - analysis.baselineShift;
						const spaceAdvance = this._getSpaceAdvance(analysis.font, analysis.fontSize);

						if (isSideBySide && i > 0) {
							currentX += this.state.analyses[i - 1].canvas.width + (lastAdvance / 2) + (spaceAdvance / 2);
						}

						const isBlend = useBlend && i > 0;
						this._drawDensityGraph(analysis, this.config.colors[i], yOffset, isBlend);
						this._drawTintedText(analysis.canvas, this.config.colors[i], currentX, yOffset, isBlend);

						lastAdvance = spaceAdvance;
					});

					this.queueUpdateDisplayScale();
					this.updateResults();
				}

				_calculateCanvasDimensions(analyses) {
					const isSideBySide = this.dom.renderMode.value === 'side-by-side' && analyses.length > 1;

					const totalAscent = Math.max(0, ...analyses.map(a => a.baseline - a.baselineShift));
					const totalDescent = Math.max(0, ...analyses.map(a => (a.canvas.height - a.baseline) + a.baselineShift));

					let totalWidth;
					if (isSideBySide) {
						const space1 = this._getSpaceAdvance(analyses[0].font, analyses[0].fontSize);
						const space2 = this._getSpaceAdvance(analyses[1].font, analyses[1].fontSize);
						totalWidth = analyses.reduce((sum, a) => sum + a.canvas.width, (space1 / 2) + (space2 / 2));
					} else {
						totalWidth = Math.max(0, ...analyses.map(a => a.canvas.width));
					}

					return {
						width: Math.ceil(this.config.graphWidth + this.config.graphPadding + totalWidth),
						height: Math.ceil(totalAscent + totalDescent),
						baseline: Math.ceil(totalAscent)
					};
				}

				_drawDensityGraph({ densityMap }, color, yOffset, blend) {
					const maxDensity = Math.max(1, ...densityMap);
					Object.assign(this.ctx, {
						fillStyle: color,
						globalCompositeOperation: blend ? 'multiply' : 'source-over',
					});
					for (let y = 0; y < densityMap.length; y++) {
						const barWidth = (densityMap[y] / maxDensity) * this.config.graphWidth;
						if (barWidth > 0) this.ctx.fillRect(this.config.graphWidth - barWidth, y + yOffset, barWidth, 1);
					}
					this.ctx.globalCompositeOperation = 'source-over';
				}

				_drawTintedText(sourceCanvas, color, x, y, blend) {
					const { tintCanvas, tintCtx, ctx } = this;
					Object.assign(tintCanvas, { width: sourceCanvas.width, height: sourceCanvas.height });

					tintCtx.clearRect(0, 0, tintCanvas.width, tintCanvas.height);
					tintCtx.fillStyle = color;
					tintCtx.fillRect(0, 0, tintCanvas.width, tintCanvas.height);
					tintCtx.globalCompositeOperation = 'destination-in';
					tintCtx.drawImage(sourceCanvas, 0, 0);

					ctx.globalCompositeOperation = blend ? 'multiply' : 'source-over';
					ctx.drawImage(tintCanvas, x, y);

					tintCtx.globalCompositeOperation = 'source-over';
					ctx.globalCompositeOperation = 'source-over';
				}

				_renderEmpty() {
					Object.assign(this.dom.canvas, { width: 400, height: 200 });
					this.ctx.clearRect(0, 0, 400, 200);
					this.queueUpdateDisplayScale();
				}

				updateDisplayScale() {
					const { style, parentElement, width } = this.dom.canvas;
					if (this.dom.zoomMode.value !== 'fit' || width === 0) {
						style.transform = 'none';
						return;
					}
					const padding = parseFloat(getComputedStyle(parentElement).paddingLeft) * 2;
					const availableWidth = parentElement.parentElement.clientWidth - padding;
					style.transform = `scale(${Math.min(availableWidth / width, 1)})`;
				}

				updateResults() {
					this.state.analyses.forEach((analysis, i) => {
						const el = this.dom.fontControls[i].results;
						if (analysis) {
							const { yMin, yMax, density, fontSize, baselineShift, letterSpacing, metrics } = analysis;
							el.textContent = [
								`Y Min: ${yMin}px`, `Y Max: ${yMax}px`,
								`Density: ${density}%`, `Font Size: ${fontSize}px`,
								`Baseline Shift: ${baselineShift}px`, `Letter Spacing: ${letterSpacing}px`,
								`Actual Ascent: ${Math.round(metrics.actualAscent)}px`,
								`Actual Descent: ${Math.round(metrics.actualDescent)}px`,
								`Font Ascent: ${Math.round(metrics.fontAscent)}px`,
								`Font Descent: ${Math.round(metrics.fontDescent)}px`
							].join('\n');
						} else {
							el.textContent = this.state.fonts[i] ? 'Enter text to analyze.' : 'Load a font to see analysis.';
						}
					});
				}

				exportPNG() {
					const link = Object.assign(document.createElement('a'), {
						href: this.dom.canvas.toDataURL('image/png'),
						download: 'typographic-density.png'
					});
					link.click();
				}

				_getSpaceAdvance(font, fontSize) {
					const advance = font.getAdvanceWidth(' ', fontSize);
					if (advance > 0) {
						return advance;
					}
					const scale = fontSize / font.unitsPerEm;
					return (font.unitsPerEm / 4) * scale;
				}
			}

			document.addEventListener('DOMContentLoaded', () => new FontDensityAnalyzer());
		</script>
	</body>
</html>