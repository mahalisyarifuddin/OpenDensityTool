<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Typographic Density Tool</title>
		<style>
			:root {
				--primary: #1976d2;
				--hover: #004080;
				--bg: #f9f9ff;
				--surface: #fff;
				--text: #181c21;
				--border: #c1c6d4;
				--dim: #e0e2ec;
				--success: #2e8534;
				--danger: #ba1a1a
			}

			@media(prefers-color-scheme: dark) {
				:root:not(.light) {
					--bg: #101319;
					--surface: #0b0e14;
					--text: #e0e2ea;
					--border: #414752;
					--dim: #44474f
				}
			}

			:root.dark {
				--bg: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--dim: #44474f
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			*:focus-visible {
				outline: 2px solid var(--primary);
				outline-offset: 2px
			}

			body {
				background: var(--bg);
				color: var(--text);
				font-family: sans-serif;
				line-height: 1.25;
				padding: 1.5rem;
				min-height: 100vh
			}

			header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 2rem;
				max-width: 1600px;
				margin-left: auto;
				margin-right: auto
			}

			h1 {
				margin: .5rem 0;
				font-size: 2rem;
				font-weight: 600
			}

			main {
				display: grid;
				grid-template-columns: 340px 1fr;
				gap: 1.5rem;
				max-width: 1600px;
				margin: 0 auto
			}

			section {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 1.5rem;
				min-width: 0
			}

			h2 {
				margin: .5rem 0 1rem;
				border-bottom: 1px solid var(--border);
				padding-bottom: .75rem;
				font-size: 1.2rem;
				font-weight: 600
			}

			.group {
				background: var(--bg);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				margin-bottom: 1rem;
				position: relative;
				transition: border-color .15s,background-color .15s
			}

			.group.drag-active {
				border-color: var(--primary);
				background: var(--surface)
			}

			.group.drag-active::after {
				content: "Drop Font File";
				position: absolute;
				inset: 0;
				background: var(--surface);
				color: var(--primary);
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				font-weight: 700;
				border-radius: 6px;
				z-index: 10
			}

			.header {
				display: flex;
				align-items: center;
				margin-bottom: .75rem;
				font-weight: 700
			}

			.header span {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				min-width: 0
			}

			input[type=color] {
				width: 24px;
				height: 24px;
				border: none;
				background: none;
				padding: 0;
				margin-right: .5em;
				cursor: pointer;
				flex-shrink: 0
			}

			label {
				display: block;
				margin-bottom: .5rem;
				font-weight: 500;
				font-size: .9rem
			}

			input:not([type=color]),textarea,select,button {
				width: 100%;
				padding: .5rem .75rem;
				border: 1px solid var(--border);
				border-radius: 4px;
				background: var(--surface);
				color: var(--text);
				margin-top: 4px;
				font-family: inherit;
				font-size: .95rem
			}

			textarea {
				resize: vertical;
				min-height: 80px;
				font-family: monospace;
				font-size: .8rem
			}

			.row {
				display: flex;
				gap: 1rem
			}

			.controls {
				display: flex;
				gap: .75rem;
				align-items: center;
				margin-bottom: 1rem
			}

			.controls-selects {
				display: flex;
				flex-wrap: wrap;
				gap: .75rem;
				flex: 1
			}

			.controls select {
				width: auto;
				margin-top: 0
			}

			button {
				background: var(--primary);
				color: #fff;
				border: 0;
				padding: .5rem 1rem;
				cursor: pointer;
				transition: background .1s;
				width: auto;
				margin-top: 0;
				flex-shrink: 0
			}

			button:hover {
				background: var(--hover)
			}

			#preview {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 6px;
				overflow: auto;
				margin-bottom: 1.5rem
			}

			#container {
				padding: 1rem;
				display: flex;
				align-items: flex-start
			}

			canvas {
				transform-origin: top left;
				display: block;
				flex-shrink: 0
			}

			.results {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 1rem
			}

			.card {
				background: var(--bg);
				border: 1px solid var(--border);
				padding: 1rem;
				border-radius: 6px;
				min-width: 0
			}

			.output {
				font-family: monospace;
				font-size: .8rem;
				line-height: 1.5;
				margin-top: .5rem
			}

			.stat-grid {
				display: grid;
				gap: .5rem
			}

			.stat-row {
				display: flex;
				justify-content: space-between;
				align-items: center
			}

			.stat-group {
				margin-top: .5rem;
				border-top: 1px solid var(--border);
				padding-top: .5rem
			}

			.stat-group-title {
				font-weight: 600;
				margin-bottom: .25rem;
				color: var(--text)
			}

			.stat-label {
				color: var(--text);
				opacity: .8
			}

			.stat-value {
				font-weight: 600
			}

			.indicator {
				width: 14px;
				height: 14px;
				border-radius: 3px;
				display: inline-block;
				margin-right: .5em;
				flex-shrink: 0
			}

			.action-btn {
				margin-left: auto;
				background: transparent;
				color: var(--primary);
				border: 1px solid transparent;
				padding: .25rem .5rem;
				font-size: .8rem;
				border-radius: 4px
			}

			.action-btn:hover {
				background: var(--bg);
				border-color: var(--dim)
			}

			.spinner {
				width: 24px;
				height: 24px;
				border: 3px solid var(--border);
				border-top-color: var(--primary);
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin: 1rem auto
			}

			@keyframes spin {
				to {
					transform: rotate(360deg)
				}
			}

			[hidden] {
				display: none!important
			}

			@media(max-width: 900px) {
				main {
					grid-template-columns:1fr
				}

				.results {
					grid-template-columns: 1fr
				}
			}
		</style>
	</head>
	<body>
		<header>
			<h1>Typographic Density Tool</h1>
			<select id="theme" style="width:auto" aria-label="Color theme">
				<option value="auto">Auto Theme</option>
				<option value="light">Light</option>
				<option value="dark">Dark</option>
			</select>
		</header>
		<main>
			<section>
				<h2>Configuration</h2>
				<div class="group">
					<div class="header">
						<input type="color" id="color1" value="#00a2a2" aria-label="Font 1 Color">
						<span id="name1">Font 1</span>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file1" style="margin-bottom:0">Font File</label>
						<button id="clear1" class="action-btn" aria-label="Clear Font 1" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file1" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<label>
						Text<textarea id="text1" maxlength="1000">Idealogy</textarea>
					</label>
					<label>
						Size (px)<input type="number" id="size1" value="100" min="8" max="500">
					</label>
					<div class="row">
						<label>
							Letter Spacing<input type="number" id="spacing1" value="0" min="-100" max="100">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift1" value="0" min="-200" max="200">
						</label>
					</div>
				</div>
				<div class="group">
					<div class="header">
						<input type="color" id="color2" value="#ff00ff" aria-label="Font 2 Color">
						<span id="name2">Font 2</span>
					</div>
					<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
						<label for="file2" style="margin-bottom:0">Font File</label>
						<button id="clear2" class="action-btn" aria-label="Clear Font 2" title="Clear font">Clear</button>
					</div>
					<input type="file" id="file2" accept=".otf,.ttf,.woff,.woff2" style="margin-top:0">
					<label>
						Text<textarea id="text2" maxlength="1000">Идеология</textarea>
					</label>
					<label>
						Size (px)<input type="number" id="size2" value="100" min="8" max="500">
					</label>
					<div class="row">
						<label>
							Letter Spacing<input type="number" id="spacing2" value="0" min="-100" max="100">
						</label>
						<label>
							Baseline Shift<input type="number" id="shift2" value="0" min="-200" max="200">
						</label>
					</div>
				</div>
			</section>
			<section>
				<h2>Visualization</h2>
				<div class="controls">
					<div class="controls-selects">
						<select id="zoom" aria-label="Zoom level">
							<option value="fit">Fit to View</option>
							<option value="100">100% Scale</option>
						</select>
						<select id="render" aria-label="Render mode">
							<option value="overlay">Overlay</option>
							<option value="side">Side-by-side</option>
						</select>
						<select id="density" aria-label="Density calculation method">
							<option value="ink">Ink Box</option>
							<option value="em">Em Box</option>
						</select>
						<select id="guides" aria-label="Guides">
							<option value="none">No Guides</option>
							<option value="baseline">Show Baseline</option>
							<option value="metrics">Show Metrics</option>
						</select>
					</div>
					<button id="export">Export PNG</button>
				</div>
				<div id="preview">
					<div id="container">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div class="results">
					<div class="card">
						<div class="header">
							<div id="dot1" class="indicator"></div>
							<span id="analysisName1">Font 1 Analysis</span>
							<button class="action-btn copy-btn" data-target="result1" aria-label="Copy Font 1 analysis">Copy</button>
						</div>
						<div id="result1" class="output" aria-live="polite"></div>
					</div>
					<div class="card">
						<div class="header">
							<div id="dot2" class="indicator"></div>
							<span id="analysisName2">Font 2 Analysis</span>
							<button class="action-btn copy-btn" data-target="result2" aria-label="Copy Font 2 analysis">Copy</button>
						</div>
						<div id="result2" class="output" aria-live="polite"></div>
					</div>
				</div>
			</section>
		</main>
		<script type="module">
            import * as fontkitModule from 'https://esm.sh/fontkit@2.0.4';
            import { Buffer } from 'https://esm.sh/buffer@6.0.3';

            const fontkit = fontkitModule.default || fontkitModule;
            window.Buffer = Buffer; // Necessary for fontkit

			const dom = new Proxy({},{
				get: (_,id)=>document.getElementById(id)
			});

			class DensityTool {
				constructor() {
					this.fonts = [];
					this.loadErrors = [];
					this.loading = [false, false];
					this.loadCounters = [0, 0];
					this.renderCache = [];
					this.analysisCanvases = [document.createElement('canvas'), document.createElement('canvas')];
					this.graphWidth = 150;
					this.graphPadding = 20;
					this.context = dom.canvas.getContext('2d');
					this.bind();
					this.setTheme('auto');
					this.update();
				}

				bind() {
					const schedule = callback=>{
						let frame;
						return ()=>(frame && cancelAnimationFrame(frame),
						frame = requestAnimationFrame(callback));
					}
					;
					const debounce = (callback,delay)=>{
						let timer;
						return (...args)=>(clearTimeout(timer),
						timer = setTimeout(()=>callback(...args), delay));
					}
					;
					const refresh = schedule(()=>this.update())
					  , debouncedRefresh = debounce(()=>this.update(), 300)
					  , resize = schedule(()=>this.updateScale());

					dom.zoom.onchange = resize;
					['render', 'density', 'guides'].forEach(id=>dom[id].onchange = refresh);
					dom.export.onclick = ()=>Object.assign(document.createElement('a'), {
						href: dom.canvas.toDataURL(),
						download: `density_${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.png`
					}).click();
					dom.theme.onchange = event=>this.setTheme(event.target.value);
					window.onresize = resize;

					document.querySelectorAll('.copy-btn').forEach(button=>{
						const original = button.textContent;
						button.onclick = ()=>navigator.clipboard.writeText(document.getElementById(button.dataset.target).innerText).then(()=>button.textContent = 'Copied!').catch(()=>button.textContent = 'Error').finally(()=>setTimeout(()=>button.textContent = original, 2000));
					}
					);

					[1, 2].forEach((number,index)=>{
						const file = dom[`file${number}`]
						  , group = file.closest('.group');
						file.onchange = event=>this.loadFont(event.target.files[0], index);
						dom[`clear${number}`].onclick = ()=>(this.fonts[index] = this.loadErrors[index] = null,
						file.value = '',
						this.update());
						['color', 'text', 'size', 'spacing', 'shift'].forEach(key=>dom[`${key}${number}`].oninput = debouncedRefresh);

						group.ondragover = event=>(event.preventDefault(),
						group.classList.add('drag-active'));
						group.ondragleave = event=>(!event.relatedTarget || !group.contains(event.relatedTarget)) && group.classList.remove('drag-active');
						group.ondrop = event=>{
							event.preventDefault();
							group.classList.remove('drag-active');
							const dropped = event.dataTransfer.files[0];
							dropped && (file.files = event.dataTransfer.files,
							this.loadFont(dropped, index));
						}
						;
					}
					);
				}

				setTheme(theme) {
					document.documentElement.classList.remove('light', 'dark');
					theme !== 'auto' && document.documentElement.classList.add(theme);
					dom.theme.value = theme;
				}

				getFontName(font, number) {
					if (!font)
						return `Font ${number}`;
					return font.fullName || font.familyName || font.postscriptName || `Font ${number}`;
				}

				async loadFont(file, index) {
					const loadId = ++this.loadCounters[index];
					this.loadErrors[index] = this.fonts[index] = null;
					this.loading[index] = true;
					this.update();

					try {
						if (!file)
							return;
						if (file.size > 30 << 20)
							throw new Error('File too large (max 30MB)');
						let buffer = await file.arrayBuffer();
						if (loadId === this.loadCounters[index]) {
                            const buf = window.Buffer.from(buffer);
							const font = fontkit.create(buf);
                            if (!font.unitsPerEm) throw new Error('Invalid font');
							this.fonts[index] = font;
						}
					} catch (error) {
						loadId === this.loadCounters[index] && (this.loadErrors[index] = error.message);
					} finally {
						loadId === this.loadCounters[index] && (this.loading[index] = false,
						this.update());
					}
				}

				getRenderData(index) {
					const number = index + 1;
					const inputs = {
						font: this.fonts[index],
						content: dom[`text${number}`].value,
						fontSize: +dom[`size${number}`].value || 0,
						letterSpacing: +dom[`spacing${number}`].value || 0,
						color: dom[`color${number}`].value
					};
					if (!inputs.font || !inputs.content || !inputs.fontSize)
						return null;
					const cached = this.renderCache[index];
					return cached && Object.keys(inputs).every(key=>cached.inputs[key] === inputs[key]) ? cached.data : this.generateRenderData(index, inputs);
				}

				generateRenderData(index, inputs) {
					const {font, content, fontSize, letterSpacing, color} = inputs;
					const size = Math.max(1, Math.min(fontSize, 2000));
					const scale = size / font.unitsPerEm;
                    const tracking = letterSpacing ? (letterSpacing / size) * font.unitsPerEm : 0;

					const fontAscent = (font.ascent || 0) * scale;
					const fontDescent = Math.abs(font.descent || 0) * scale;
					const fontXHeight = (font.xHeight || 0) * scale;
					const fontCapHeight = (font.capHeight || 0) * scale;

                    const run = font.layout(content);
                    if (run.glyphs.length === 0) return null;

                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    let currentX = 0;

                    run.glyphs.forEach((glyph, i) => {
                        const pos = run.positions[i];
                        const x = currentX + pos.xOffset;
                        const y = pos.yOffset;

                        const bbox = glyph.bbox;
                        if (bbox) {
                             minX = Math.min(minX, x + bbox.minX);
                             maxX = Math.max(maxX, x + bbox.maxX);
                             minY = Math.min(minY, y + bbox.minY);
                             maxY = Math.max(maxY, y + bbox.maxY);
                        }

                        currentX += pos.xAdvance + tracking;
                    });

                    if (minX === Infinity) { minX = 0; maxX = 0; minY = 0; maxY = 0; }

                    const advanceWidth = Math.ceil(currentX * scale);

                    const x1 = minX * scale;
                    const x2 = maxX * scale;
                    const y1 = maxY * scale;
                    const y2 = minY * scale;

					const boundingBoxWidth = Math.ceil(x2 - x1);
					if (advanceWidth <= 0 && boundingBoxWidth <= 0)
						return null;

					const metrics = {
						ascent: Math.max(y1, fontAscent),
						descent: Math.max(-y2, fontDescent),
						fontAscent,
						fontDescent,
						fontXHeight,
						fontCapHeight,
						x1,
						x2,
						boundingBoxWidth,
						advanceWidth
					};

					const minXPixel = Math.min(0, metrics.x1);
					const maxXPixel = Math.max(metrics.advanceWidth, metrics.x2);
					const drawOffsetX = -minXPixel;
					const width = Math.ceil(maxXPixel - minXPixel);
					const baseline = Math.ceil(metrics.ascent);
					const height = Math.ceil(baseline + metrics.descent);

					if (width > 32767 || height > 32767)
						throw new Error('Canvas dimensions too large');

					const fontCanvas = this.analysisCanvases[index];
					fontCanvas.width = Math.max(fontCanvas.width, width);
					fontCanvas.height = Math.max(fontCanvas.height, height);
					const context = fontCanvas.getContext('2d', {
						willReadFrequently: true
					});
					context.clearRect(0, 0, width, height);
					context.save();
					context.translate(drawOffsetX, baseline);
                    context.scale(1, -1);

                    context.fillStyle = color;

                    let drawX = 0;
                    run.glyphs.forEach((glyph, i) => {
                        const pos = run.positions[i];
                        const x = drawX + pos.xOffset;
                        const y = pos.yOffset;

                        context.save();
                        context.translate(x * scale, y * scale);
                        glyph.render(context, size);
                        context.restore();

                        drawX += pos.xAdvance + tracking;
                    });

					context.restore();

					const data = {
						...this.analyzePixels(fontCanvas, width, height),
						...metrics,
						drawOffsetX,
						width,
						height,
						canvas: fontCanvas,
						baseline,
						letterSpacing,
						fontSize: size,
						font
					};
					this.renderCache[index] = {
						inputs,
						data
					};
					return data;
				}

				analyze(index) {
					const number = index + 1;
					try {
						const data = this.getRenderData(index);
						if (!data)
							return null;
						const hasInk = data.maxY >= data.minY;
						const area = Math.max(1, dom.density.value === 'ink' ? (hasInk ? (data.maxX - data.minX + 1) * (data.maxY - data.minY + 1) : 1) : Math.max(1, data.advanceWidth) * (data.ascent + data.descent));
						return {
							...data,
							baselineShift: +dom[`shift${number}`].value || 0,
							density: ((data.inkPixels / area) * 100).toFixed(1),
							yMin: hasInk ? Math.round(data.baseline - data.maxY) : 0,
							yMax: hasInk ? Math.round(data.baseline - data.minY) : 0
						};
					} catch (error) {
						return {
							error: error.message
						};
					}
				}

				analyzePixels(canvas, width, height) {
					const {data} = canvas.getContext('2d', {
						willReadFrequently: true
					}).getImageData(0, 0, width, height);
					const densityByRow = new Float32Array(height);
					let inkPixels = 0
					  , minX = width
					  , maxX = -1
					  , minY = height
					  , maxY = -1;

					for (let y = 0; y < height; y++) {
						let rowInk = 0;
						for (let x = 0, i = y * width * 4 + 3; x < width; x++,
						i += 4) {
							data[i] >= 128 && (rowInk++ === 0 && x < minX && (minX = x),
							x > maxX && (maxX = x));
						}
						rowInk > 0 && (inkPixels += rowInk,
						densityByRow[y] = rowInk,
						y < minY && (minY = y),
						maxY = y);
					}
					return {
						densityByRow,
						inkPixels,
						minX,
						maxX,
						minY,
						maxY
					};
				}

				update() {
					this.analyses = [1, 2].map((number,index)=>(dom[`dot${number}`].style.backgroundColor = dom[`color${number}`].value,
					this.analyze(index)));
					this.draw();
					[1, 2].forEach((number,index)=>this.updateResult(number, index));
				}

				draw() {
					const valid = this.analyses.filter(analysis=>analysis && !analysis.error);
					if (!valid.length) {
						dom.canvas.height = 150;
						this.updateScale();
						return;
					}

					const dimensions = this.computeDimensions(valid);
					dom.canvas.width = dimensions.width;
					dom.canvas.height = dimensions.height;

					const side = dom.render.value === 'side' && valid.length > 1;
					let translateX = this.graphWidth + this.graphPadding + (side ? 0 : dimensions.maxDrawOffsetX);

					this.analyses.forEach((analysis,index)=>{
						analysis && !analysis.error && this.drawAnalysis(analysis, index, dimensions, side, translateX);
						side && analysis && !analysis.error && (translateX += analysis.canvas.width);
					}
					);

					const guides = dom.guides.value;
					if (['baseline', 'metrics'].includes(guides)) {
						this.context.fillStyle = 'rgba(255, 0, 0, 0.5)';
						this.context.fillRect(0, dimensions.baseline, dom.canvas.width, 1);
					}

					if (guides === 'metrics') {
						valid.forEach((analysis, index) => {
							const y = dimensions.baseline - analysis.baselineShift;
							this.context.fillStyle = dom[`color${index + 1}`].value;
							this.context.globalAlpha = 0.5;
							this.context.fillRect(0, Math.floor(y - analysis.fontAscent), dom.canvas.width, 1);
							this.context.fillRect(0, Math.floor(y + analysis.fontDescent), dom.canvas.width, 1);

							this.context.globalAlpha = 0.3;
							if (analysis.fontCapHeight) {
								this.context.fillRect(0, Math.floor(y - analysis.fontCapHeight), dom.canvas.width, 1);
							}
							if (analysis.fontXHeight) {
								this.context.fillRect(0, Math.floor(y - analysis.fontXHeight), dom.canvas.width, 1);
							}
							this.context.globalAlpha = 1.0;
						});
					}
					this.updateScale();
				}

				drawAnalysis(analysis, index, dimensions, side, translateX) {
					const y = dimensions.baseline - analysis.baseline - analysis.baselineShift;
					const blend = index > 0 && this.analyses.every(item=>item && !item.error);
					const color = dom[`color${index + 1}`].value;

					this.context.globalCompositeOperation = blend ? 'multiply' : 'source-over';
					const max = Math.max(1, ...analysis.densityByRow);
					this.context.fillStyle = color;
					analysis.densityByRow.forEach((value,rowY)=>value && this.context.fillRect(this.graphWidth - (value / max) * this.graphWidth, rowY + y, (value / max) * this.graphWidth, 1));

					const graphX = side ? translateX + (analysis.drawOffsetX || 0) : translateX;
					this.context.drawImage(analysis.canvas, 0, 0, analysis.width, analysis.height, graphX - (analysis.drawOffsetX || 0), y, analysis.width, analysis.height);
					this.context.globalCompositeOperation = 'source-over';
				}

				computeDimensions(analyses) {
					const side = dom.render.value === 'side' && analyses.length > 1;
					const max = callback=>Math.max(0, ...analyses.map(callback));
					const maxAscent = max(item=>item.baseline + item.baselineShift)
					  , maxDescent = max(item=>item.height - item.baseline - item.baselineShift)
					  , maxOffsetX = max(item=>item.drawOffsetX);
					const width = side ? analyses.reduce((total,item)=>total + item.width, 0) : maxOffsetX + max(item=>item.width - item.drawOffsetX);
					return {
						width: Math.ceil(this.graphWidth + this.graphPadding + width),
						height: Math.ceil(maxAscent + maxDescent),
						baseline: Math.ceil(maxAscent),
						maxDrawOffsetX: maxOffsetX
					};
				}

				updateScale() {
					const {canvas, container, preview} = dom;
					canvas.style.transform = 'none';
					container.style.width = container.style.height = container.style.overflow = '';
					if (dom.zoom.value !== 'fit' || !canvas.width)
						return;

					const style = getComputedStyle(container);
					const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
					const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
					const scale = Math.min((preview.clientWidth - paddingX) / canvas.width, 1);

					canvas.style.transform = `scale(${scale})`;
					container.style.width = `${canvas.width * scale + paddingX}px`;
					container.style.height = `${canvas.height * scale + paddingY}px`;
					container.style.overflow = 'hidden';
				}

				updateResult(number, index) {
					const analysis = this.analyses[index]
					  , root = dom[`result${number}`];
					const message = this.loadErrors[index] ? `Error: ${this.loadErrors[index]}` : !this.fonts[index] ? 'Load font.' : !analysis ? 'Enter text.' : analysis.error ? `Error: ${analysis.error}` : '';
					const name = this.getFontName(this.fonts[index], number);

					dom[`name${number}`].textContent = dom[`name${number}`].title = name;
					dom[`analysisName${number}`].textContent = dom[`analysisName${number}`].title = `${name} Analysis`;
					dom[`color${number}`].setAttribute('aria-label', `${name} Color`);
					dom[`analysisName${number}`].nextElementSibling.setAttribute('aria-label', `Copy ${name} analysis`);

					root.innerHTML = this.loading[index] ? '<div class="spinner" aria-label="Loading"></div>' : message ? `<div class="state-message">${message}</div>` : `<div class="stat-grid"><div class="stat-row"><span class="stat-label">Density</span><span class="stat-value">${analysis.density}%</span></div><div class="stat-group"><div class="stat-group-title">Ink Bounds</div><div class="stat-row"><span class="stat-label">Max Y</span><span class="stat-value">${analysis.yMax}</span></div><div class="stat-row"><span class="stat-label">Min Y</span><span class="stat-value">${analysis.yMin}</span></div></div><div class="stat-group"><div class="stat-group-title">Metrics</div><div class="stat-row"><span class="stat-label">Ascent</span><span class="stat-value">${Math.round(analysis.fontAscent)}</span></div><div class="stat-row"><span class="stat-label">Cap Height</span><span class="stat-value">${Math.round(analysis.fontCapHeight)}</span></div><div class="stat-row"><span class="stat-label">x-Height</span><span class="stat-value">${Math.round(analysis.fontXHeight)}</span></div><div class="stat-row"><span class="stat-label">Descent</span><span class="stat-value">${Math.round(analysis.fontDescent)}</span></div></div></div>`;
				}
			}

			new DensityTool();
		</script>
	</body>
</html>
